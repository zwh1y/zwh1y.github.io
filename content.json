{"meta":{"title":"Kun's blog","subtitle":"","description":"code study","author":"Kun","url":"http://yoursite.com","root":"/"},"pages":[{"title":"所有分类","date":"2022-05-28T06:52:20.873Z","updated":"2022-05-11T09:47:20.437Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-28T06:52:20.872Z","updated":"2022-05-12T00:42:11.344Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"为天地立心，为生民立命，为往圣继绝学，为万世开太平"},{"title":"","date":"2022-05-28T06:52:20.872Z","updated":"2022-05-11T15:26:09.476Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"friends","date":"2022-05-11T09:46:26.000Z","updated":"2022-05-11T09:46:26.779Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2022-05-11T09:26:21.404Z","comments":true,"path":"page/index.html","permalink":"http://yoursite.com/page/index.html","excerpt":"","text":"This is a page test."},{"title":"所有标签","date":"2022-05-28T06:52:20.872Z","updated":"2022-05-11T09:47:03.050Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第三讲 搜索与图论（算法基础课）","slug":"AcWing算法基础课/第三讲 搜索与图论（算法基础课）","date":"2022-05-15T12:41:03.000Z","updated":"2022-05-17T01:50:13.132Z","comments":true,"path":"2022/05/15/AcWing算法基础课/第三讲 搜索与图论（算法基础课）/","link":"","permalink":"http://yoursite.com/2022/05/15/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%B8%89%E8%AE%B2%20%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA%EF%BC%88%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%EF%BC%89/","excerpt":"本系列源自：y总 算法基础课，收获很大，强烈推荐。 链接：https://www.acwing.com/activity/content/introduction/11/ 下面是我对于y总课程内容的总结，以及一些个人的思考","text":"本系列源自：y总 算法基础课，收获很大，强烈推荐。 链接：https://www.acwing.com/activity/content/introduction/11/ 下面是我对于y总课程内容的总结，以及一些个人的思考 第三讲 搜索与图论 深度优先搜索 DFS 宽度优先搜索 BFS 树与图的存储 树与图的深度优先遍历 树与图的宽度优先遍历 拓扑排序 数据结构 空间 DFS stack $O(h)$ BFS queue $O(2^h)$ “最短路” 1. 深度优先搜索 DFSDFS 重要的是顺序，没有特定的模版 重要概念： 回溯 剪枝：提前判断，当前方案一定是不合法的，下面的子树就不用判断了，一定是不合法的，直接把枝剪掉，直接回溯。 最优化剪枝：当前路径一定不如最优解 可行性剪枝： 当前路径一定不合法 从搜索树的角度考虑，每一个DFS都对应一颗搜索树 842. 排列数字给定一个整数 nn，将数字 1∼n1∼n 排成一排，将会有很多种排列方法。 现在，请你按照字典序将所有的排列方法输出。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;const int N = 10;int n;int path[N];bool st[N];void dfs(int u)&#123; if(u &gt;= n) &#123; for(int i = 0; i &lt; n; i++) cout &lt;&lt; path[i] &lt;&lt; &#x27; &#x27;; puts(&quot;&quot;); return; &#125; for(int i = 1; i &lt;= n; i++) if(!st[i]) &#123; path[u] = i; st[i] = true; dfs(u + 1); st[i] = false; &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs(0); return 0;&#125; 843. $n$-皇后问题$n$−皇后问题是指将$n$个皇后放在 $n×n$的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。 处理方法： 斜线处理，通过截距判断在斜线上是否有两个皇后 !dg[u + i] &amp;&amp; !udg[n - u + i] !dg[x + y] &amp;&amp; !udg[x - y + n] （n - x + y 和x - y + n都可以实现，重要的是两种斜线的截距区分，没有必要追求哪个是x轴哪个是y轴） 第一种做法：枚举每一行123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int N = 20;int n;char g[N][N];bool col[N], dg[N], udg[N];void dfs(int u)&#123; if(u == n) &#123; for(int i = 0; i &lt; n; i++) puts(g[i]); puts(&quot;&quot;); return; &#125; for(int i = 0; i &lt; n; i++) if(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) &#123; g[u][i] = &#x27;Q&#x27;; col[i] = dg[u + i] = udg[n - u + i] = true; dfs(u + 1); col[i] = dg[u + i] = udg[n - u + i] = false; g[u][i] = &#x27;.&#x27;; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) g[i][j] = &#x27;.&#x27;; dfs(0); return 0;&#125; 第二种做法：枚举所有格子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;const int N = 20;int n;char g[N][N];bool row[N], col[N], dg[N], udg[N];void dfs(int x, int y, int s)&#123; if(y == n) y = 0, x++; if(x == n) &#123; if(s == n) &#123; for(int i = 0; i &lt; n; i++) puts(g[i]); puts(&quot;&quot;); &#125; return; &#125; // 不放皇后 dfs(x, y + 1, s); // 放皇后 if(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n]) &#123; g[x][y] = &#x27;Q&#x27;; row[x] = col[y] = dg[x + y] = udg[x - y + n] = true; dfs(x, y + 1, s + 1); row[x] = col[y] = dg[x + y] = udg[x - y + n] = false; g[x][y] = &#x27;.&#x27;; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) g[i][j] = &#x27;.&#x27;; dfs(0, 0, 0); return 0;&#125; 2. 宽度优先搜索 BFS 边权都是1，可以使用BFS求解最短路问题，不是所有最短路都能用BFS，一般用专门的最短路算法（时间复杂度高） DP和最短路问题是互通的：DP可以看作是一种特殊的最短路问题，DP时间复杂度低 模版： 123456queue &lt;- 初始while queue 不为空&#123; t &lt;- 队头 拓展t&#125; 844. 走迷宫123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 110;int n, m;int g[N][N];int d[N][N];PII q[N * N];int bfs()&#123; int hh = 0, tt = 0; q[0] = &#123;0, 0&#125;; memset(d, -1, sizeof d); d[0][0] = 0; int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; while(hh &lt;= tt) &#123; auto t = q[hh++]; for(int i = 0; i &lt; 4; i++) &#123; int x = t.first + dx[i], y = t.second + dy[i]; if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1) &#123; d[x][y] = d[t.first][t.second] + 1; q[++tt] = &#123;x, y&#125;; &#125; &#125; &#125; return d[n - 1][m - 1];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) cin &gt;&gt; g[i][j]; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125; 树和图的深度优先遍历 树是一种特殊的图：无环连通图（只需要考虑图） 有向图、无向图：无向图是一种特殊的有向图（只需要考虑有向图） 存储方式 能否存储重边 适用于 邻接矩阵 二维数组 不能（保留一条） 稠密图 邻接表 单链表 能 稀疏图 树和图的存储 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 10, M = N * 2;int h[N], e[M], ne[M], idx;void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++;&#125;int main()&#123; // 初始化 memset(h, -1, sizeof h);&#125; 树和图的遍历（DFS）： 12345678910111213141516171819202122232425262728293031323334 #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 10, M = N * 2;int n, m;int h[N], e[M], ne[M], idx;bool st[N];void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++;&#125;void dfs(int u)&#123; st[u] = true; // 标记一下，已经被搜过了 for(int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if(!st[j]) dfs(j); &#125;&#125;int main()&#123; // 初始化 memset(h, -1, sizeof h); dfs(1);&#125; 846. 树的重心题目分析： 求出每一个点，删除该点之后，其余所有连通块的点数的最大值，这之中的最小值就是答案 实现思路： 我们可以通过树的深度遍历，求出每个点子树的点的数量 子树的点的数量，通过dfs返回 该点除子树外的点的数量，可以通过 n - Size[n] 在递归的过程中，处理每一个点的时候，都能算出在把它删除了之后，其余所有部分的连通块的大小，就能找到一个最大值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 10, M = N * 2;int n, m;int h[N], e[M], ne[M], idx;bool st[N];int ans = N; // 全局答案void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++;&#125;// 以u为根的子树的点的数量int dfs(int u)&#123; st[u] = true; // 标记一下，已经被搜过了 int sum = 1, res = 0; // sum：以u为根的子树的点的数量，最开始自己本身这一个点 for(int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if(!st[j]) // 被搜索过，可以理解为上面的点 &#123; int s = dfs(j); // s：点u的子树j的点的数量 res = max(res, s); // 比较得出子树中连通块的最大的值 sum += s; // 记录下以u为根的子树的点的数量 &#125; &#125; res = max(res, n - sum); // n - sum：上面的连通块的数量 ans = min(res, ans); // 每个点计算得到的最大值比较，选取最小的 return sum;&#125;int main()&#123; cin &gt;&gt; n; // 初始化 memset(h, -1, sizeof h); for(int i = 0; i &lt; n - 1; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b), add(b, a); &#125; dfs(1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 树和图的广度优先遍历847. 图中的点的层次给定一个$n$个点$m$条边的有向图，图中可能存在重边和自环。 所有边的长度都是1，点的编号为$1 \\sim n$。 请你求出 11 号点到 nn 号点的最短距离，如果从 11 号点无法走到 nn 号点，输出 −1−1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int n, m;int h[N], e[N], ne[N], idx;int d[N], q[N];void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++;&#125;int bfs()&#123; int hh = 0, tt = 0; q[0] = 1; memset(d, -1, sizeof d); d[1] = 0; while(hh &lt;= tt) &#123; int t = q[hh++]; for(int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if(d[j] == -1) &#123; d[j] = d[t] + 1; q[++tt] = j; &#125; &#125; &#125; return d[n];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for(int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); &#125; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125; 拓扑排序（图的层次遍历的应用）有向无环图一定存在拓扑序列（拓扑图） 度数： 入度：有多少条边指向自己 出度：有多少条边指向外面 848. 有向图的拓扑序列给定一个$n$个点$m$条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。 请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。 若一个由图中所有点构成的序列 AA 满足：对于图中的每条边 $(x,y)$，$x$ 在 AA 中都出现在 $y$ 之前，则称 $A$ 是该图的一个拓扑序列。 入度为0的点都可以作为起点 一个无环图至少存在一个入度为0的点（反证法） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int n, m;int h[N], e[N], ne[N], idx;int q[N], d[N];void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++;&#125;bool topsort()&#123; int hh = 0, tt = -1; // 队列中添加入度为0的点 for(int i = 1; i &lt;= n; i++) if(!d[i]) q[++tt] = i; while(hh &lt;= tt) &#123; int t = q[hh++]; for(int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; d[j] --; if(d[j] == 0) q[++tt] = j; // 如果入度为0则加入序列 &#125; &#125; return tt == n - 1;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for(int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); d[b]++; &#125; if(topsort()) &#123; for(int i = 0; i &lt; n; i++) cout &lt;&lt; q[i] &lt;&lt; &#x27; &#x27;; &#125; else puts(&quot;-1&quot;); return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"AcWing算法基础课","slug":"算法/AcWing算法基础课","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"第二讲 数据结构（算法基础课）","slug":"AcWing算法基础课/第二讲 数据结构（算法基础课）","date":"2022-05-15T12:31:03.000Z","updated":"2022-05-15T12:47:28.819Z","comments":true,"path":"2022/05/15/AcWing算法基础课/第二讲 数据结构（算法基础课）/","link":"","permalink":"http://yoursite.com/2022/05/15/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%EF%BC%89/","excerpt":"本系列源自：y总 算法基础课，收获很大，强烈推荐。 链接：https://www.acwing.com/activity/content/introduction/11/ 下面是我对于y总课程内容的总结，以及一些个人的思考","text":"本系列源自：y总 算法基础课，收获很大，强烈推荐。 链接：https://www.acwing.com/activity/content/introduction/11/ 下面是我对于y总课程内容的总结，以及一些个人的思考 第二讲 数据结构","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"AcWing算法基础课","slug":"算法/AcWing算法基础课","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"第一讲 基础算法（算法基础课）","slug":"AcWing算法基础课/第一讲 基础算法（算法基础课）","date":"2022-05-15T02:29:04.000Z","updated":"2022-05-15T12:45:10.509Z","comments":true,"path":"2022/05/15/AcWing算法基础课/第一讲 基础算法（算法基础课）/","link":"","permalink":"http://yoursite.com/2022/05/15/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%B8%80%E8%AE%B2%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%EF%BC%89/","excerpt":"本系列源自：y总 算法基础课，收获很大，强烈推荐。 链接：https://www.acwing.com/activity/content/introduction/11/ 下面是我对于y总课程内容的总结，以及一些个人的思考","text":"本系列源自：y总 算法基础课，收获很大，强烈推荐。 链接：https://www.acwing.com/activity/content/introduction/11/ 下面是我对于y总课程内容的总结，以及一些个人的思考 第一讲 基础算法主要思想：代码为什么是对的、为什么这样写，需要有一个深刻的理解。 课后： 背过代码（快速的默写出模版，调试之后能过） 课后习题 （）每个题目写个3-5遍 1. 快速排序（已过）思想：基于分治 快速排序 思想： 确定分界点：q[l] q[r] q[l + r &gt;&gt; 1] 调整区间：x左边的数都小于等于x， x右边的数都大于等于x 递归处理左右两段 复习出现的错误： do while循环不熟练，do后面的i++也需要加上； 递归处理的时候越界了，写的分界点是j-1和j？？？（暂时不知道为什么）经过测试，使用i-1和i分界也会出错，使用 + 1就不会。 x = l + r &gt;&gt; 1出错，如果我们不使用x = q[l + r &gt;&gt; 1]。这里如果每次记住的是下标，那么每次都是那个固定的下标，然而下标的固定并不能保证下标里面存放的值是固定的，尤其是在进行swap交换的过程中，可能会出现对应的值发生了变化，如果此时坚持使用q[下标] 当下标对应的位置改变的时候q[下标]第k个数也会改变，但是我们选点的时候是根据一个固定的值，左边全部小于等于x右边全部大于等于x。违背了这个初衷就会WA 我们每次while循环需要用同一个值来进行比较，如果保存下标的话，在交换后可能导致同一个while循环中比较的数改变，从而造成错误。 Sl和Sr表示的是个数 重点思想： 多了一个k，排序之后，通过左边的数和右边数的个数辅助判断 2. 归并排序思想：基于分治 归并排序 思想： 确定分界点：mid &#x3D; (l + r) &gt;&gt; 2 和快速排序的区别是快速排序是数组中的值，而这里用的是下标 递归排序 left right 归并 合并两个有序的数组 代码实现： 递归终止情况 分成子问题，递归处理子问题 合并子问题 123456789101112131415161718192021void merge_sort(int q[], int l, int r)&#123; //递归的终止情况 if(l &gt;= r) return; //第一步：分成子问题 int mid = l + r &gt;&gt; 1; //第二步：递归处理子问题 merge_sort(q, l, mid ), merge_sort(q, mid + 1, r); //第三步：合并子问题 int k = 0, i = l, j = mid + 1, tmp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) if(q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while(i &lt;= mid) tmp[k++] = q[i++]; while(j &lt;= r) tmp[k++] = q[j++]; for(k = 0, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];&#125; 边界分析： 为什么不用 mid - 1 作为分隔线呢？ 即 merge_sort(q, l, mid - 1 ), merge_sort(q, mid, r) 因为 mid &#x3D; l + r &gt;&gt; 1 是向下取整，mid 有可能取到 l (数组只有两个数时)，造成无限划分 解决办法: mid 向上取整就可以了, 即 mid &#x3D; l + r + 1 &gt;&gt; 1,如下所示: 逆序对的数量 3. 二分二分的本质是二段性 有单调性一定可以二分，没有单调性也有可能可以二分 重点： 1. check需要自己定义去找一个最合适的 数的范围 图示如下： mid &#x3D; l + r + 1&gt;&gt; 1 找小于等于x的数，判断 mid &lt;&#x3D; x是否成立 if(check(mid)) true [mid, r] 更新：l &#x3D; mid ​ false [l, mid - 1] 更新：r &#x3D; mid - 1 mid &#x3D; l + r &gt;&gt; 1 找大于等于x的数，判断mid &gt;&#x3D; x是否成立 if(check(mid)) true [l, mid] 更新：r &#x3D; mid ​ false[mid + 1, r] 更新：l &#x3D; mid + 1 是否加1:看更新区间，如果是l &#x3D; mid就需要补一个 + 1，如果是r&#x3D;mid就不需要补上+ 1。 如何理解mid +1还是-1: 判断q[mid] &gt;&#x3D; x，不满足的话，mid就不会在区间内,更新后的区间要靠近r，所以要让 l &#x3D; mid + 1 判断q[mid] &lt;&#x3D; x，不满足的话，mid就不会在区间内,更新后的区间要靠近l，所以要让 r &#x3D; mid - 1 浮点数二分浮点数二分，没有精度问题，好写 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; double x; cin &gt;&gt; x; double l = 0, r = x; while(r - l &gt; 1e-8)&#123; // 精度提高，比输出多2就没问题 double mid = (l + r)/2; if(mid*mid &gt;= x) r = mid; else l = mid; &#125; printf(&quot;%lf\\n&quot;, l); return 0;&#125; 循环写法(区间变为原来的100分之一) 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; double x; cin &gt;&gt; x; double l = 0, r = x; for(int i = 0; i &lt; 100; i++)&#123; double mid = (l + r)/2; if(mid*mid &gt;= x) r = mid; else l = mid; &#125; printf(&quot;%lf&quot;, l); return 0;&#125; 4. 高精度c++需要 java中有大整数类 python默认是无限大 A &lt;&#x3D; 10与len(A) &lt; 10 0-9999999999 都是使用大数组进行存储 处理中使用到了A[i] - ‘0’（自动转换为ASCII码的值相减）相减得到的就是数值 高精度加法 大数组存储 模拟人工加法的过程 每次计算的时候使用到了三个数Ai Bi 以及 t（进位） 使用数组表示A B C（使用vector数组就可以不需要额外使用变量来获取长度） 使用一个t来表示进位 高精度减法 需要保证 A &gt;&#x3D; B, 如果A &lt;B，则计算B-A加上一个负号 设计到负数就使用绝对值计算出再进行符号判断 t表示是当前位数的数值，以及用来判断是否借位（取值为1或者0） 注意：去掉前导0（除非数值为0） 高精度乘法 与高精度加法类似，利用到t来计算进位 高精度除法 5. 前缀和与差分（其实是一对逆运算）前缀和注意： 就是算出前n项和，比较简单 题目一遍问的是第几个数到第几个数，所以从1开始会比较好理解，不容易出错。 子矩阵的和注意： 输出的计算：s[x2][y2] - s[x2][y1 - 1] -s[x1 - 1][y2] + s[x1 - 1][y1 - 1] 差分（不需要考虑如何构造，只要考虑如何）差分数组是一个数组 存放的是相邻数据之间的差值 假象一个b数组，b的前缀和是a，b被称为a的差分 用处：O(1)的时间解决原来O(n)的问题 **假定a1 - an都是0，差分数组也就是都是0，假定插入了n次插入操作，每次让原数组[n, n]的区间插入a[n]**：插入操作操作就可以直接使用到公式（在原数组a的一段区间中插入值）： 1234void insert(int l, int r, int c)&#123; b[l] += c; b[r + 1] -= c;&#125; 差分矩阵（二维差分） 令aij等于0，显然bij等于零，再根据aij实际值，插入一遍就好了 公式： 123456void insert(int x1, int y1, int x2, int y2, int c)&#123; b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -=c; b[x2+1][y2+1] +=c;&#125; 6. 双指针算法核心思想：将一个复杂度更高的计算，优化 两大类： 归并排序 快速排序 j表示j往左，最左能到什么地方 先写下面的模版，再如何去做 12345for(i=0, j=0; i&lt;n; i++)&#123; while(j &lt; i &amp;&amp; check(i, j)) j++; // 每道题的具体逻辑&#125; 核心思想： 通过暴力先写暴力做法 在枚举的时候看，i和j的单调关系 利用单调关系把枚举数量从n^2变成n 1234for(int i = 0; i &lt; n; i++) for(int j = 0; j&lt; n; j++) O(n^2)// 将上面的朴素算法优化到O(n) 简单的例题：将每个单词分别输出且各占一行。 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; char str[1000]; gets(str); int n = strlen(str); for(int i = 0; str[i]; i++)&#123; int j = i; while(j &lt; n &amp;&amp; str[j] != &#x27; &#x27;) j++; // 这道题的具体逻辑 for(int k = i; k &lt; j; k++) cout &lt;&lt; str[k]; cout &lt;&lt; endl; i = j; &#125;&#125; 最长连续不重复子序列核心思路： 遍历数组a中的每一个元素a[i], 对于每一个i，找到j使得双指针[j, i]维护的是以 a[i]结尾 的最长连续不重复子序列，长度为i - j + 1, 将这一长度与r的较大者更新给r。 对于每一个i，如何确定j的位置：由于[j, i - 1]是前一步得到的最长连续不重复子序列，所以如果[j, i]中有重复元 素，一定是a[i]，因此右移j直到a[i]不重复为止（由于[j, i - 1]已经是前一步的最优解，此时j只可能右移以剔除重复元素a[i]，不可能左移增加元素，因此，j具有“单调性”、本题可用双指针降低复杂度）。 用数组s记录子序列a[j ~ i]中各元素出现次数，遍历过程中对于每一个i有四步操作：cin元素a[i] -&gt; 将a[i]出现次数s[a[i]]加1 -&gt; 若a[i]重复则右移j（s[a[j]]要减1） -&gt; 确定j及更新当前长度i - j + 1给r。 注意细节： 当a[i]重复时，先把a[j]次数减1，再右移j。 暴力：遍历起点和终点(i在右边，j在左边) 12345678// 朴素做法： O(n^2)for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt;= i; j++)&#123; if(check(i, j))&#123; res = max(res, i - j + 1); &#125; &#125;&#125; 双指针算法： 找到单调性等新的性质，简化时间复杂度 1234for(int i = 0， j = 0; i &lt; n; i++)&#123; while(j &lt;= i &amp;&amp; check(j, i)) j++; res = max(res, i - j + 1);&#125; 数组元素的目标和判断子序列 7. 位运算 n的二进制表示中第k位是几（个位是第0位） 先把第k位移到最后一位 n &gt;&gt; k 看各位是几 x&amp;1 结合1、2之后，常用操作：n &gt;&gt; k &amp; 1 lowbit(x)：返回x的最后一位1 x &#x3D; 1010 lowbit(x) &#x3D; 10(2) x &#x3D; 101000 lowbit(x) &#x3D; 1000(4) 实现原理：x&amp;-x -x &#x3D; x + 1所以x&amp;-x &#x3D; x&amp;(x+1) 二进制中1的个数(上述应用) 8. 离散化（整数有序） 值域很大，但是内容稀疏 将下标离散化 区间和 将下标离散化之后，离散化之后的下标插入对应的值，同时离散化的下标包括查找的区间，形成一个新的数组进行处理。 将下标拿过来排序，映射到从1开始的自然数，利用前缀和计算 给x加c 找x离散化之后的数是多少 L,R 也会放到离散化的容器中，这样可以方便找到需要求的值 unique实现： 它是第一个数 它和前一个数不一样，即：a[i] !&#x3D; a[i-1] 9. 区间合并区间合并 按左端点排序 存在三种情况，分别来看如何对区间进行更新（由于已经排序且是从左到右进行扫描，因此左端点不可能在目前区间左边） 在目前的区间内 左端点在区间内，右端点在区间外 左端点在区间外","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"AcWing算法基础课","slug":"算法/AcWing算法基础课","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"0. 绪论（白板推导）","slug":"白板推导/0-绪论（白板推导）","date":"2022-05-14T15:58:26.000Z","updated":"2022-05-15T02:45:24.418Z","comments":true,"path":"2022/05/14/白板推导/0-绪论（白板推导）/","link":"","permalink":"http://yoursite.com/2022/05/14/%E7%99%BD%E6%9D%BF%E6%8E%A8%E5%AF%BC/0-%E7%BB%AA%E8%AE%BA%EF%BC%88%E7%99%BD%E6%9D%BF%E6%8E%A8%E5%AF%BC%EF%BC%89/","excerpt":"本系列源自：shuhuai008 https://space.bilibili.com/97068901/channel/series 参考自：https://www.yuque.com/books/share/f4031f65-70c1-4909-ba01-c47c31398466","text":"本系列源自：shuhuai008 https://space.bilibili.com/97068901/channel/series 参考自：https://www.yuque.com/books/share/f4031f65-70c1-4909-ba01-c47c31398466","categories":[{"name":"ML & DL","slug":"ML-DL","permalink":"http://yoursite.com/categories/ML-DL/"},{"name":"白板推导系列","slug":"ML-DL/白板推导系列","permalink":"http://yoursite.com/categories/ML-DL/%E7%99%BD%E6%9D%BF%E6%8E%A8%E5%AF%BC%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://yoursite.com/tags/ML/"},{"name":"白板推导","slug":"白板推导","permalink":"http://yoursite.com/tags/%E7%99%BD%E6%9D%BF%E6%8E%A8%E5%AF%BC/"}]},{"title":"CMake基础学习","slug":"CMake基础学习","date":"2022-05-12T13:45:23.000Z","updated":"2022-05-12T15:35:48.674Z","comments":true,"path":"2022/05/12/CMake基础学习/","link":"","permalink":"http://yoursite.com/2022/05/12/CMake%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"本文转载自：https://www.bilibili.com/video/BV1vR4y1u77h?spm_id_from=333.337.search-card.all.click 作者：刘贝斯 我对这篇笔记进行了部分修改以增加可读性，强烈想要推荐入门CMake的朋友看一下up的视频和官方文档。 埋坑：我要写好官方文档的笔记","text":"本文转载自：https://www.bilibili.com/video/BV1vR4y1u77h?spm_id_from=333.337.search-card.all.click 作者：刘贝斯 我对这篇笔记进行了部分修改以增加可读性，强烈想要推荐入门CMake的朋友看一下up的视频和官方文档。 埋坑：我要写好官方文档的笔记 说明cmake的定义是什么 ？—–高级编译配置工具 当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了—–CMake！ 所有操作都是通过编译CMakeLists.txt来完成的—简单 官方网站是 www.cmake.org，可以通过访问官方网站获得更多关于 cmake 的信息 学习CMake的目的，为将来处理大型的C&#x2F;C++&#x2F;JAVA项目做准备 CMake安装1、绝大多数的linux系统已经安装了CMake 2、Windows或某些没有安装过的linux系统，去http://www.cmake.org/HTML/Download.html 可以下载安装 CMake一个HelloWord命令行1、步骤一，写一个HelloWord 1234567#main.cpp#include &lt;iostream&gt;int main()&#123;std::cout &lt;&lt; &quot;hello word&quot; &lt;&lt; std::endl;&#125; 2、步骤二，写CMakeLists.txt 1234567891011#CMakeLists.txtPROJECT (HELLO)SET(SRC_LIST main.cpp)MESSAGE(STATUS &quot;This is BINARY dir &quot; $&#123;HELLO_BINARY_DIR&#125;)MESSAGE(STATUS &quot;This is SOURCE dir &quot;$&#123;HELLO_SOURCE_DIR&#125;)ADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;) 3、步骤三、使用cmake，生成makefile文件 123456789101112131415161718192021222324252627cmake .输出：[root@localhost cmake]# cmake .CMake Warning (dev) in CMakeLists.txt: Syntax Warning in cmake code at /root/cmake/CMakeLists.txt:7:37 Argument not separated from preceding token by whitespace.This warning is for project developers. Use -Wno-dev to suppress it.-- The C compiler identification is GNU 10.2.1-- The CXX compiler identification is GNU 10.2.1-- Check for working C compiler: /usr/bin/cc-- Check for working C compiler: /usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working CXX compiler: /usr/bin/c++-- Check for working CXX compiler: /usr/bin/c++ -- works-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- This is BINARY dir /root/cmake-- This is SOURCE dir /root/cmake-- Configuring done-- Generating done-- Build files have been written to: /root/cmake 目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile. 4、使用make命令编译 12345root@localhost cmake]# makeScanning dependencies of target hello[100%] Building CXX object CMakeFiles/hello.dir/main.cpp.oLinking CXX executable hello[100%] Built target hello 5、最终生成了Hello的可执行程序 vscode在完成前三个步骤之后，可以在vscode下方选择kit，在选择右边的建立，就能够生成build文件（与命令行中的文件一致） CMake一个HelloWord-的语法介绍PROJECT关键字可以用来指定工程的名字和支持的语言，默认支持所有语言 123456PROJECT (HELLO) # 工程名字PROJECT (HELLO C CXX JAVA) # 指定工程名字，并且支持C、C++、JavaPROJECT (HELLO) # 指定了工程的名字，并且支持所有语言—建议PROJECT (HELLO CXX) # 指定了工程的名字，并且支持语言是C++PROJECT (HELLO C CXX) # 指定了工程的名字，并且支持语言是C和C++ 该指定隐式定义了两个CMAKE的变量 _BINARY_DIR，本例中是 HELLO_BINARY_DIR _SOURCE_DIR，本例中是 HELLO_SOURCE_DIR MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译 问题： 如果改了工程名，这两个变量名也会改变 解决： 又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系 123MESSAGE(STATUS &quot;This is BINARY dir &quot; $&#123;HELLO_BINARY_DIR&#125;)MESSAGE(STATUS &quot;This is SOURCE dir &quot;$&#123;HELLO_SOURCE_DIR&#125;) SET关键字用来显示的指定变量的 SET(SRC_LIST main.cpp) SRC_LIST变量就包含了main.cpp 123SET(SRC_LIST main.cpp) SET(SRC_LIST main.cpp t1.cpp t2.cpp) MESSAGE关键字向终端输出用户自定义的信息 主要包含三种信息： SEND_ERROR，产生错误，生成过程被跳过。 SATUS，输出前缀为–的信息。 FATAL_ERROR，立即终止所有 cmake 过程. ADD_EXECUTABLE关键字生成可执行文件 123ADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;) # 生成可执行文件hello，源文件读取变量SRC_LIST中的内容ADD_EXECUTABLE(hello main.cpp) # 简写 上述例子（五行代码）可以简化的写成 123PROJECT(HELLO)ADD_EXECUTABLE(hello main.cpp) 注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的 语法的基本原则 变量使用 ${} 方式取值，但是在 IF 控制语句中是直接使用变量名 指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用 空格 或 分号 分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件 就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp) 或者 ADD_EXECUTABLE(hello main.cpp;func.cpp) 指令是大小写无关的，参数和变量是大小写相关的。推荐使用大写指令 语法注意事项 SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号 ADD_EXECUTABLE(hello main) 后缀可以不加，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main 内部构建和外部构建 上述例子就是内部构建，他生产的临时文件特别多，不方便清理 外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式。（这不就是我之前用vscode直接实现的么） 外部构建方式举例123456789mkdir buildcd buildcmake .. # 注意这里有一个空格make./hello 1、建立一个build目录，可以在任何地方，建议在当前目录下 2、进入build，运行cmake .. 当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了 3、在build目录下，运行make来构建工程 注意外部构建的两个变量 1、HELLO_SOURCE_DIR 还是工程路径 2、HELLO_BINARY_DIR 编译路径 也就是 &#x2F;root&#x2F;cmake&#x2F;bulid 让Hello World看起来更像一个工程 为工程添加一个子目录 src，用来放置工程源代码 添加一个子目录 doc，用来放置这个工程的文档 hello.txt 在工程目录添加文本文件 COPYRIGHT, README 在工程目录添加一个 runhello.sh 脚本，用来调用 hello 二进制 将构建后的目标文件放入构建目录的 bin 子目录 将 doc 目录 的内容以及 COPYRIGHT&#x2F;README 安装到&#x2F;usr&#x2F;share&#x2F;doc&#x2F;cmake&#x2F; 将目标文件放入构建目录的 bin 子目录 mac没有tree命令，可以使用 brew install tree 每个目录下都要有一个CMakeLists.txt说明 1234567[root@localhost cmake]# tree.├── build├── CMakeLists.txt└── src ├── CMakeLists.txt └── main.cpp 外层CMakeLists.txt 123PROJECT(HELLO)ADD_SUBDIRECTORY(src bin) # src表示和src文件相关联 # bin表示生产的二进制文件、可执行文件等都会放入bin目录中，bin会自动新建 src下的CMakeLists.txt 1ADD_EXECUTABLE(hello main.cpp) ADD_SUBDIRECTORY 指令ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) (在最外层告诉CMake有src) 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置 EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example ADD_SUBDIRECTORY(src bin) 将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录 如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build&#x2F;src 目录 更改二进制的保存路径SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置 SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}&#x2F;bin)SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}&#x2F;lib) 思考：加载哪个CMakeLists.txt当中 哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写 123456789101112131415# 命令行使用mkdir srcmv main.cpp srccd srctouch CMakeLists.txtcd ..cat CMakeLists.txt # 查看文件内容echo &quot;&quot; &gt; CMakeLists.txt # 清空文件 安装 一种是从代码编译后直接 make install 安装 一种是打包时的指定 目录安装。 简单的可以这样指定目录：make install DESTDIR&#x3D;&#x2F;tmp&#x2F;test 稍微复杂一点可以这样指定目录：.&#x2F;configure –prefix&#x3D;&#x2F;usr 如何安装HelloWord使用CMAKE一个新的指令：INSTALL INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等 使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX 123456789101112131415// 目录树结构[root@localhost cmake]# tree.├── build├── CMakeLists.txt├── COPYRIGHT├── doc│ └── hello.txt├── README├── runhello.sh└── src ├── CMakeLists.txt └── main.cpp3 directories, 7 files 安装文件COPYRIGHT和READMEINSTALL(FILES COPYRIGHT README DESTINATION share&#x2F;doc&#x2F;cmake&#x2F;) 1INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/) # 相对路径 FILES：文件 DESTINATION： 1、写绝对路径 2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}&#x2F;&lt;DESTINATION 定义的路径&gt; CMAKE_INSTALL_PREFIX 默认是在 &#x2F;usr&#x2F;local&#x2F; cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr 在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径 安装脚本runhello.shPROGRAMS：非目标文件的可执行程序安装(比如脚本之类) 1INSTALL(PROGRAMS runhello.sh DESTINATION bin) 说明：实际安装到的是 &#x2F;usr&#x2F;bin 安装 doc 中的 hello.txt 一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file 二、是直接在工程目录通过 1INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake) DIRECTORY 后面连接的是所在 Source 目录的相对路径 注意：abc 和 abc&#x2F;有很大的区别 目录名不以&#x2F;结尾：这个目录将被安装为目标路径下的 目录名以&#x2F;结尾：将这个目录中的内容安装到目标路径 安装过程cmake .. make make install 遇到报错： 解决办法： sudo make install 静态库和动态库的构建任务： 建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 安装头文件与共享库。 静态库和动态库的区别 静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。 静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行 动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。 构建实例12345678[root@localhost cmake2]# tree.├── build├── CMakeLists.txt└── lib ├── CMakeLists.txt ├── hello.cpp └── hello.h hello.h中的内容 123456#ifndef HELLO_H#define Hello_Hvoid HelloFunc();#endif hello.cpp中的内容 12345#include &quot;hello.h&quot;#include &lt;iostream&gt;void HelloFunc()&#123; std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;&#125; 项目中的cmake内容 12PROJECT(HELLO)ADD_SUBDIRECTORY(lib bin) lib中CMakeLists.txt中的内容 12SET(LIBHELLO_SRC hello.cpp)ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;) ADD_LIBRARYADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so(我的mac生产的动态库的后缀是.dylib) SHARED，动态库 STATIC，静态库 ${LIBHELLO_SRC} ：源文件 同时构建静态和动态库1234567// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.aADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)ADD_LIBRARY(hello STATIC $&#123;LIBHELLO_SRC&#125;)// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)ADD_LIBRARY(hello_static STATIC $&#123;LIBHELLO_SRC&#125;) SET_TARGET_PROPERTIES这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本 同时构建静态和动态库 123456789101112131415SET(LIBHELLO_SRC hello.cpp)ADD_LIBRARY(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)# 对hello_static的重名为helloSET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME &quot;hello&quot;)# cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a# 如果不进行清理就会创建失败SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)SET_TARGET_PROPERTIES(hello PROPERTIES OUTPUT_NAME &quot;hello&quot;)SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1) 动态库的版本号一般动态库都有一个版本号的关联 123libhello.so.1.2libhello.so -&gt;libhello.so.1libhello.so.1-&gt;libhello.so.1.2 CMakeLists.txt 插入如下 SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1) VERSION 指代动态库版本，SOVERSION 指代 API 版本。 安装共享库和头文件本例中我们将 hello 的共享库安装到&#x2F;lib目录， 将 hello.h 安装到&#x2F;include&#x2F;hello 目录 123456# 文件放到该目录下INSTALL(FILES hello.h DESTINATION include/hello)# 二进制，静态库，动态库安装都用TARGETS# ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib) 注意： 安装的时候，指定一下路径，放到系统下 cmake -D CMAKE_INSTALL_PREFIX=/usr .. 使用外部共享库和头文件准备工作，新建一个目录来使用外部共享库和头文件 1234567[root@MiWiFi-R4CM-srv cmake3]# tree.├── build├── CMakeLists.txt└── src ├── CMakeLists.txt └── main.cpp main.cpp 12345#include &lt;hello.h&gt;int main()&#123; HelloFunc();&#125; 解决：make后头文件找不到的问题PS：include &lt;hello&#x2F;hello.h&gt; 这样include是可以，这么做的话，就没啥好讲的了 关键字：INCLUDE_DIRECTORIES 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割 在CMakeLists.txt中加入头文件搜索路径 INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello) 感谢： 网友：zcc720的提醒 解决：找到引用的函数问题报错信息：undefined reference to &#96;HelloFunc()’ 关键字：LINK_DIRECTORIES 添加非标准的共享库搜索路径 指定第三方库所在路径，LINK_DIRECTORIES(&#x2F;home&#x2F;myproject&#x2F;libs) 关键字：TARGET_LINK_LIBRARIES 添加需要链接的共享库 TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。 在CMakeLists.txt中插入链接共享库，主要要插在executable的后面 查看main的链接情况 12345678[root@MiWiFi-R4CM-srv bin]# ldd main linux-vdso.so.1 =&gt; (0x00007ffedfda4000) libhello.so =&gt; /lib64/libhello.so (0x00007f41c0d8f000) libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f41c0874000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f41c0572000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f41c035c000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f41bff8e000) /lib64/ld-linux-x86-64.so.2 (0x00007f41c0b7c000) 链接静态库 TARGET_LINK_LIBRARIES(main libhello.a) 特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置 我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello)来指明include路径的位置 我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH&#x3D;&#x2F;usr&#x2F;include&#x2F;hello 补充：生产debug版本的方法：cmake .. -DCMAKE_BUILD_TYPE&#x3D;debug","categories":[],"tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"music test","slug":"音乐测试","date":"2022-05-11T15:29:02.000Z","updated":"2022-05-15T12:46:58.962Z","comments":true,"path":"2022/05/11/音乐测试/","link":"","permalink":"http://yoursite.com/2022/05/11/%E9%9F%B3%E4%B9%90%E6%B5%8B%E8%AF%95/","excerpt":"","text":"","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"http://yoursite.com/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"3D Object","slug":"SRT3D","date":"2022-05-11T15:29:02.000Z","updated":"2022-05-12T15:35:34.744Z","comments":true,"path":"2022/05/11/SRT3D/","link":"","permalink":"http://yoursite.com/2022/05/11/SRT3D/","excerpt":"","text":"abstract： 基于区域的方法很火热，但是计算成本高，需求资源多。 我们提出了SRT3D可以减小效率上的差距 我们的模型认为图像信息会沿着对应线稀疏（correspondence lines），对应线会模拟物体的位置概率 引入smoothed step functions（平滑阶跃函数，西瓜书看到的翻译），用于考量定义的全局和局部的不确定性，对产生的概率公式进行分析 使用预渲染的稀疏视点模型（sparse viewpoint model）为对象姿势创建联合后验概率。 使用牛顿…优化 运行时间和质量比现有技术好，尤其是噪声和杂乱图像。 Introduction 计算机是觉得重要任务之一：跟踪三维空间中的刚体并预测其六自由度。在虚拟现实和机器人都有应用 给定连续的图像帧，3D目标追踪的目标是：估计对象相对于相机的旋转和平移。 概述现有技术、相关工作、我们的方法和贡献 1.1 3D Object Tracking主流方法： 3D目标追踪 优点 缺点 key-points 应用广泛、最在不同阶段引入了深度学习 需要丰富的纹理（rich texture） explicit edges 提供格外的信息来源 在复杂场景容易失败（cluttered sccenes） direct optimization 优化了光度误差（photometric error） 需要丰富的纹理（rich texture） motion blur会改变纹理的边缘导致格外问题。 deep learning 使用CNNs考量完整图像信息，效果好 少数算法能够实时进行、每秒少于30帧、需要高端GPUs、耗时、需要有纹理的3D模型 depth information 使用深度相机（depth cameras）结合深度和RGB信息，总体可以得到更好的效果 很多应用中，不能使用深度传感器。 由于硬件、表面距离、表面特征和照明条件难以得到算法需要的高质量图像 image regions 在复杂场景中追踪对象、仅使用单目RGB相机和无纹理3D模型过去方法计算成本高，但是我们克服了这一缺点解决了动态模糊的问题，可以快速移动的物体 1.2 Related Work 基于区域的方法使用图像统计以区分目标所对应的前景和背景。 目标：找到最能展示图像分割的目标姿势以及轮廓。 潜力：挑战背景下，鲁棒追踪 最终，PWP3D将分割和追踪结合的方法以及像素级后验成员身份（ the pixel-wise posterior membership）结合，是使用水平集姿势的实时算法。它是几乎所有先进的基于区域的方法的基础。 大量算法对PWP3D进行了改进，如结合格外信息、拓展分割模型、提高效率、使用基于ICP的算法拓展能量函数、使用3D符号距离函数将藕和区域与深度信息结合到概率公式中、使用像素强度值或描述区域（descriptor fields）直接优化目标纹理、基于边缘的使用一个轮廓部分模型的技术。。。一直在介绍不同的技术，但是都只提一句话。 最后引入自己的技术 1.3 Contribution 我们致力于开发SRT3D，一种高效、稀疏的基于区域的跟踪方法。为了降低复杂性，我们使用区域信息和采用全局分割模型。我们在先前工作的基础上考虑沿对应线的稀疏图像信息，牛顿优化与Tikhonov正则化被用来估计对象的姿态。 我们的贡献： 对应线的形式定义和描述轮廓位置的概率模型数学推导 对全局和局部不确定性建模的新的平滑阶跃函数 参数对后验概率分布的影响 全局和局部优化策略以及局部一阶导数的新近似 之后先将对应线模型的建模，再将算法实现细节。我们的算法在RBOT和OPT上比现有技术效果和质量都更好 Correspondence Line Model 对应线的形式化数学定义 考虑将对应线分割为前景和背景的概率模型 拓展模型和提供离散比例公式 新的平滑阶跃函数以及其配置是如何影响轮廓位置的后验概率的 2.1 Correspondence Lines 我们考虑沿对应线稀疏地处理像素值（类似于ICP，先定义对应关系，再优化） 建立模型：根据传统的图像的定义建立对应线的定义，并表示出二者关系 $$\\mathbf {l} \\left (r \\right ) &#x3D; I \\left ( \\mathbf {c} +r \\mathbf {n} \\right ) \\tag {1}$$ 2.2 Probabilistic Model 提出了一个概率模型，用于将对应线分割为前景区域$\\omega_f$和背景区域$\\omega_b$。这相当于分割二维图像到区域 到$\\Omega_f$和$\\Omega_b$ 我们假定前景到背景只有一个过渡（translation），通过线中心（line center） $\\mathbf{c}$和相对（$\\mathbf{c}$）距离$d$ 从对应线上的单个像素的形成开始推导，联合概率分布如下$$p\\left(r, \\mathbf{y}, d, m\\right ) &#x3D; p\\left (r\\space| \\space d, m\\right )p(\\mathbf{y} \\space |\\space m )p(m)p(d) \\tag{2}$$ 符号解释：$r$：line coordinate（线坐标） $\\mathbf{y}$：image values（图像值）这里应该是单个像素的值 $d$：contour distance 相对于线中心$c$的距离 $m$：$m\\in \\left { m_f,m_b \\right } $ 表示前景或者背景的模型参数 将条件设置为$y$：$$p\\left(r, d, m \\space | \\space \\mathbf{y} \\right ) &#x3D;p\\left (r\\space| \\space d, m\\right )p(m\\space |\\space \\mathbf{y} )p(d) \\tag{3}$$ 推导过程： 由于$P(X,Y) &#x3D; P(X)P(X\\space |\\space Y)$ $p\\left (r\\space| \\space d, m\\right )p(\\mathbf{y} \\space |\\space m )p(m)p(d)&#x3D; p(\\mathbf{y} )p(r,d,m\\space |\\space \\mathbf{y} )$ $p(r,d,m\\space |\\space \\mathbf{y} )&#x3D; \\frac{p\\left (r\\space| \\space d, m\\right )p(\\mathbf{y} \\space |\\space m )p(m)p(d)}{p(\\mathbf{y} )} $ $\\frac{(\\mathbf{y} \\space |\\space m )p(m)}{p(\\mathbf{y} )} &#x3D; p(m \\space | \\space \\mathbf{y})$ $p\\left(r, d, m \\space | \\space \\mathbf{y} \\right ) &#x3D;p\\left (r\\space| \\space d, m\\right )p(m\\space |\\space \\mathbf{y} )p(d)$ 得证 使用贝叶斯和边缘化覆盖$m$来计算像素级后验概率 $p(\\mathbf{y} \\space |\\space m_f)$和$p(\\mathbf{y} \\space |\\space m_b)$是概率分布，分别描述一个特定的颜色值属于前景区域或背景区域的可能性有多大。可以通过前景区域和后景区域的颜色分布直方图来计算（详见4.2）$$p(m_i \\space | \\space \\mathbf{y}) &#x3D; \\frac{p(\\mathbf{y} \\space |\\space m_i)p(m_i)}{ {\\textstyle \\sum_{j \\in { f,b}}^{}}p(\\mathbf{y}\\space | \\space m_j )p(m_j) } ,\\space i \\in {f, b} \\tag{4}$$ 同样可以用$P(X,Y) &#x3D; P(X)P(X\\space |\\space Y)$推出 沿对应线前景和背景的可能性相等$p(m_f) &#x3D; p(m_b)$$$p(m_i \\space | \\space \\mathbf{y}) &#x3D;\\frac{p(\\mathbf{y} \\space |\\space m_i)}{p(\\mathbf{y}\\space | \\space m_f )+p(\\mathbf{y}\\space |\\space m_b) } ,\\space i \\in {f, b} \\tag{5}$$基于（3），边缘化覆盖$m$和$d$在条件$r$下的后验概率$$p(d \\space | \\space r ,\\mathbf{y} ) &#x3D;\\frac{1}{p(r)}\\sum_{i \\in {f, b}}^{}p(r \\space |\\space d,m_i)p(m_i \\space |\\space \\mathbf{y} )p(d) \\tag{6}$$为了计算整个对应线域$\\omega$上的后验概率，假设像素独立，基于（6）$$p(d \\space | \\space \\omega ,\\mathbf{l} ) \\propto\\prod_{r \\in \\omega}^{}\\sum_{i \\in {f, b}}^{}p(r \\space |\\space d,m_i)p(m_i \\space |\\space \\mathbf{l}(r) ) \\tag{7}$$ $p(r)$和$p(d)$看作是常数所以删除 这是一个近似的假设，得到的结果十分接近真实值 条件线坐标概率$p(r \\space |\\space d,m_i)$在2.4提到，这个概率模型描述了从图像中给定信息的形状内核（shape kernel）的概率 公式（7）提供了等高线距离数据与对应线的概率。 2.3 Discrete Scale-Space Formulation 复杂度 用途 $p(d \\space \\space \\omega ,\\mathbf{l} )$ quadratic（平方级）每一个d都要在整个域$\\omega$ $p(m \\space \\space \\mathbf{y})$ linear（线性级） 从分布转变为像素级后验概率可以提高计算效率 此外，对对应线进行归一化处理也是有利的，可以确保指向一条对应线的线段中心的线坐标$r$指向所有对应线的线段中心。 （a line coordinate pointing to a segment center for one correspondence line points to a segment center for all correspondence lines） 我的理解：??? 这种统一的形式可以用于平滑步骤函数值的预计算，以进一步提高效率 基于先前的研究，我们将多个像素结合至线段中。离散空间尺度公式将沿对应线的连续空间投影至独立于对应线位置和方向的离散空间，如图3 同一个颜色表示一个segment（线段），蓝色和黄色的点表示segment的中心和对应的离散化后的值 偏移量∆r的选择要确保标度空间中的离散值对所有对应线都是一样的。在这个例子中，∆r指向像素之间最接近的边缘。 $$r_s &#x3D; (r - \\Delta r) \\frac{\\overline{n} }{s} \\tag{8}$$ $$d_s &#x3D; (d - \\Delta r) \\frac{\\overline{n} }{s} \\tag{9}$$ $s$：合成为一段线段segment的像素比例（数量） $\\overline{n} &#x3D; max (|n_x|,|n_y|)$：将对应线投影到最近的水平或垂直图像坐标的主要的绝对法向分量 $\\Delta r \\in R$：从对应线中心$c$到定义的像素位置的距离（c所在的像素相邻两个像素中，c更接近的那个边缘到c的距离） 我的理解：根据之前的内容的上述公式，以及d的定义：d是相对于中心点c的距离。我们可以理解为：假设r（line coordinate）为距离中心点c的距离。 这里就可以很好的解释$r&#x2F;d_s$减去偏移量$\\Delta r$乘以$\\frac{\\overline{n}}{s}$这一映射关系 例如：图示的s为2（两个像素构成一个segment），$\\overline{n}$为$n_x$（对应线距离水平线投影更近）。从最右边的黄色点来看，减去偏移量后，即$r - \\Delta r$为3个单位像素（线坐标下），$n_x$为3，$\\frac{\\overline{n}}{s}$为1.5，那么对应到$r_s$中，坐标即为1.5如图所示。 根据公式（7），离散尺度空间中的后验概率计算如下：$$p(d_s \\space | \\space \\omega_s ,\\mathbf{l}s ) \\propto\\prod{r_s \\in \\omega_s}^{}\\sum_{i \\in {f, b}}^{}p(r_s \\space |\\space d_s,m_i)p(m_i \\space |\\space \\mathbf{l_s}(r_s) ) \\tag{10}$$ $\\omega_s$：放缩后到对应线域 $\\mathbf{s} &#x3D; \\mathbf{l}_s(r_s)$：一个集值函数映射，它从按比例排列的线坐标映射到线段$s$，这是一个最接近$s$(和上文是一个意思)像素值$y$的集合 类似于公式（5），我们假设像素间具有独立性，分段后验可以被定义为：$$p(m_i \\space | \\space \\mathbf{s}) &#x3D;\\frac{\\prod_{\\mathbf{y} \\in \\mathbf{s} }p(\\mathbf{y} \\space |\\space m_i)}{\\prod_{\\mathbf{y} \\in \\mathbf{s} }p(\\mathbf{y}\\space | \\space m_f )+\\prod_{\\mathbf{y} \\in \\mathbf{s} }p(\\mathbf{y}\\space |\\space m_b) },\\space i \\in {f, b}\\tag{11}$$这个推导公式，允许使用放缩参数$s$设置线段尺寸和调整准确性和效率之间的取舍，来有效覆盖对应线域$\\omega$ （之后的公式省略了下标s，但是定义和推导对原始空间和离散化空间都有效） 2.4 Smoothed Step Functions目标：对线坐标的条件概率$p(r|d, m_f)$$p(r|d, m_b)$进行建模，因此提出了不同的平滑阶跃函数$h_f$和$h_b$ 先前的工作：验证了双曲正切曲线会导致后验概率$p(d|\\omega , l)$的高斯分布 作用：平滑斜率用于模拟与前景和背景过渡的确切位置有关的局部不确定性 错误的假设：给一个模型$m$和轮廓距离$d$，我们就可以根据$h$函数预测线坐标$r$属于轮廓线的哪一边，但是在实际应用中是错误的 存在的问题： 1. 等式（5）仍是对真实世界的不完美简化 1. 统计模型未考虑图像噪声或快速外观变化，这可能导致颜色直方图中尚未出现的像素颜色 1. 由于不完美的分割而被错误分类的像素，然后被分配到错误的颜色直方图 1. 一个纯粹依赖像素颜色的统计模型是否足以捕捉现实世界中的所有统计效果，并且能够完美地预测模型$m$ 将上述问题考虑以及前景后景建模的恒定的全局不确定性$$h_f(x)&#x3D;\\frac{1}{2}-\\alpha _h tanh \\left (\\frac{x}{2s_h} \\right ) \\tag{12}$$ $$h_b(x)&#x3D;\\frac{1}{2}+\\alpha _h tanh \\left (\\frac{x}{2s_h} \\right ) \\tag{13}$$ 振幅参数$\\alpha _h \\in \\left[0,0.5 \\right]$添加到仅考虑坡度参数$s_h \\in R^{+}$的原始定义中 对于$\\alpha$的另一种解释： 我们假设模型$m$扩展第三类$m_n$，该类$m_n$考虑独立于前景$\\omega _f$和后景$\\omega _b$的外部影响。对于这个场景，我们可以证明$p(m_f) &#x3D;p(m_b)&#x3D;\\alpha $和$p(m_n)&#x3D;1-2\\alpha$。 根据这种解释，振幅参数因此允许我们设置一个像素的颜色由前景或背景模型生成的概率，与其他一些被视为噪声的影响形成对比。 这再次表明，振幅参数α能够模拟恒定的全局不确定性。 请注意，在这种情况下，收敛到0或1的原始平滑阶跃函数用于计算$p(r|d,m_f)$和$p(r|d_m)$，而噪声模型采用恒定函数$p(r|d,m_n)&#x3D;\\frac{1}{2}$。 附录A中给出了该扩展模型的详细推导及其与等式（12）和（13）中函数使用等价性的证明。 2.5 Posteior Probability Distrubution考虑到平滑阶跃函数$h_f和h_b$建立了条件线坐标概率模型$p(r | d,m_f)和p(r | d,m_b)$，则等式（7）中后验概率分布的最终表达式可以写成$$p(d \\space | \\space \\omega ,\\mathbf{l} ) \\propto\\prod_{r \\in \\omega}^{}h_f(r-d)p_f(r) + h_b(r-d)p_b(r) \\tag{14}$$ 缩写：$p_f(r)&#x3D;p(m_f \\space |\\space \\mathbf{l}(r))和p_b(r)&#x3D;p(m_b \\space |\\space \\mathbf{l}(r))$ 假设轮廓在对应线中心和像素级后验概率$p_f和p_b$的阶跃函数 阶跃函数的假设很好地反映了现实世界中的实验，实验表明，在大多数情况下，前景和后景之间存在明显的分离 对公式取对数并关于$d$求一阶导，假设具有无穷小像素的连续函数。基于附录B，封闭解如下：$$\\frac{\\partial ln(p(d \\space | \\space \\omega, \\mathbf{l} ))}{\\partial d} &#x3D;-2tanh^{-1}\\left ( 2 \\alpha _h tanh \\left ( \\frac{d}{2s_h} \\right )\\right )\\tag{15}$$满足$\\alpha _h&#x3D;\\frac{1}{2}$和$s_h \\to 0$两种情况时，公式（15）可以简化，我们能计算后验概率分布的闭式解。 $\\alpha _h&#x3D;\\frac{1}{2}$时，我们获得了我们之前方法的平滑阶跃函数，公式（12）（13），后验概率分布会产生完美的高斯分布$$p(d \\space | \\space \\omega ,\\mathbf{l} ) &#x3D;\\frac{1}{\\sqrt[]{2\\pi s_h} }exp\\left ( -\\frac{d^2}{2s_h} \\right ) \\tag{16}$$其中斜率参数$s_h$等于方差。在$s_h \\to 0$的情况下，这导致了$h_f$和$h_b$的尖锐阶梯函数，后验概率分布成为一个完美的拉普拉斯分布$$p(d \\space | \\space \\omega ,\\mathbf{l} ) &#x3D;\\frac{1}{2b} exp\\left ( -\\frac{|d|}{b\\ } \\right ) ,b&#x3D;\\frac{1}{2tanh^-1(2 \\alpha _h)}\\tag{17}$$附录C中有详细推导 ![image-20220424142755366](..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220424142755366.png) 拉普拉斯分布（蓝色）有明显的峰值，高斯分布（黄色）有一个平滑的最大值，附近的值有类似的高概率 从图像中可以知道，$s_h$控制局部不确定性（大量的值d可能等于多少），$\\alpha _h$控制全局不确定性（控制与周围环境相比的峰值大小） Region-Based 3D Tracking内容： 定义数学概念 对稀疏视点模型的描述，这个模型避免了在跟踪过程中对三维模型的渲染 将这种几何学表示与对应线模型结合，制定出与姿势有关的联合后验概率 该概率通过牛顿优化和Tikhonov正则化实现最大化。 我们为牛顿方法定义所需的梯度向量和Hessian矩阵。因此，我们区分了全局和局部优化，以确保快速融合和高精确度。 3.1 Preliminaries 前言定义：3D模型点$\\mathbf{X} &#x3D; [X \\space Y \\space Z]^{T}\\in R^{3}$ 其次形式：$\\widetilde{\\mathbf{X}} &#x3D; [X \\space Y \\space Z \\space 1]^{T}\\in R^{3}$ 齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示，是指一个用于投影几何里的坐标系统，如同用于欧氏几何里的笛卡儿坐标一般 引入齐次坐标可以让放缩变换变得更加统一简单。例如：平移是矩阵加法，而升维之后可以用矩阵乘法实现 对于3D模型点$\\mathbf{X}$向图像空间的投影，我们假设图像不失真，并使用针孔相机模型$$x &#x3D; \\pi (\\mathbf{X} )&#x3D;\\begin{bmatrix} \\frac{X}{Z}f_x + p_x \\ \\frac{X}{Z} f_y + p_y\\end{bmatrix}\\tag{18}$$ 焦距$f_x和f_y$、关键点（principal point）$p_x和p_y$是像素级的 $x$：图像坐标 反转：从图像坐标$x$和对应深度值$d_Z$沿光轴重建为3D模型点 光轴是光学系统中一条假想的线，定义（在一次近似下）光学系统如何传导光线 $$\\mathbf{X}&#x3D;\\pi^{-1}(x, d_Z)&#x3D;d_Z\\begin{bmatrix} \\frac{x-p_x}{f_x} \\ \\frac{y-p_y}{f_y} \\ 1\\end{bmatrix}\\tag{19}$$ 使用齐次矩阵$_{C}T _M \\in SE(3)$描述相机参考系C和模型参考系M之间的相对姿态 SE(3) 是旋转加上位移， 也称欧式变换（Euclidean transformation），刚体变换（Rigid Transformation），一般我们用矩阵 来表示，其中 为旋转， t 为位移，所以有6个自由度，3个旋转，3个位置。 对于一个三维模型点的变换，我们可以写出：$$_{C} \\widetilde{X} &#x3D; _{C}T _{MM} \\widetilde{X}&#x3D;\\begin{bmatrix} _{C}R_M&amp; -{C}t_M \\ 0 &amp; 1\\end{bmatrix} \\space _{M}\\widetilde{X}\\tag{20}$$ $_{C} \\widetilde{X}$和$ \\space _{M}\\widetilde{X}$ 分别是写入相机C和参考系模型参考系M中的3D模型点 $ _{C}R_M$和$-{C}t_M$是旋转矩阵和平移向量，定义从M到C的转换 对于小的变化，使用角轴表示，这是一个最小的表示。 用指数映射，旋转矩阵写为$$\\mathbf{R} &#x3D; exp([\\mathbf{r}]_\\times)&#x3D;\\mathbf{I} + [\\mathbf{r}]_\\times +\\frac{1}{2!}[\\mathbf{r}]_\\times^{2}+\\frac{1}{3!}[\\mathbf{r}]_\\times^{3}+…\\tag{21}$$ $[\\mathbf{r}]_\\times$是斜对称矩阵,$\\mathbf{r} \\in R^3$ 忽略级数展开的高阶项，等式（21）可以线性化。然后，我们可以在相机参考系C中写入3D模型点的线性变化，如下所示：$$_C\\widetilde{X}(\\theta) &#x3D;\\begin{bmatrix} _CR_M&amp; Ct_M\\ 0&amp;1\\end{bmatrix}\\begin{bmatrix} \\mathbf{I} + [\\theta_r]_\\times &amp; \\theta _t \\ 0 &amp; 1\\end{bmatrix}\\space _M \\widetilde{X}\\tag{22}$$ $\\theta_r \\in R^3$ ：旋转变换 $\\theta _t \\in R^3$：平移变换 $\\theta ^T&#x3D;[\\theta _r^T,\\theta _t^T]$：完变换向量 改变模型参考系M的优点： 由于对象的移动量通常比相机的移动量大得多，会更加自然 使&#x3D;&#x3D;拓展为使用多相机算法&#x3D;&#x3D;成为可能 3.2 Sparse Viewpoint Model为了创建这个模型，三维几何体从物体周围的若干$n_v$视点进行渲染 虚拟摄像机被放置在围绕物体的测地网格的顶点上 对于每一个渲染，$n_c个点 \\mathbf{x_i} \\in R^2$从模型轮廓上随机采样（2D上） 单位向量$\\mathbf{n_i} \\in R^2$近似垂直于每个点（法向量） 基于2D实体，关于模型参考系，3D向量被重建：$$_M \\mathbf{\\widetilde{X} }_i &#x3D; _{M}T C \\mathbf{\\widetilde{\\pi } }^{-1}(x_i,d{Zi}) \\tag{23}$$ $$_M \\mathbf{N}_i &#x3D; _M\\mathbf{R}_C \\begin{bmatrix} \\mathbf{n} _i \\ 0\\end{bmatrix} \\tag{24}$$ $\\mathbf{ \\widetilde{\\pi }}^{-1}$：表示三维模型点以齐次形式返回（他可以将$x和d_Z$（图像值和深度）映射为3D模型点 ） $d_{Zi}$：渲染产生的深度值 $C$：表示虚拟摄像机的，参考系渲染就是从这里开始的 $_M\\mathbf{v}&#x3D;_M \\mathbf{R}_C \\mathbf{e}_Z$：方向向量，从摄像机指向模型中心$\\mathbf{e}_Z&#x3D;\\begin{bmatrix} 0 &amp; 0 &amp; 1 \\end{bmatrix}^T$ 计算的3D模型点、法向量、方向向量会被存储到每一个视图中 给定特定的姿势（$_M\\mathbf{R}_C和 _C\\mathbf{t}_M$），渲染模型和计算轮廓的过程简化为找到最接近的预计算视图$i_v$：$$i_v &#x3D; \\underset{i \\in {1,…n_v}}{arg \\space max}(_M \\mathbf{v}_i^{T}\\space _M \\mathbf{R}_C \\space _C \\mathbf{t} _M ) \\tag{25}$$然后将相应的3D模型点和法向量投影到图像中 请注意，在优化关节后验概率时，这种高效率尤其重要，因为每次迭代中姿势都会发生变化。 3.3 Joint Posterior Probability结合稀疏视点模型与对应线模型，定义关于姿势变换的联合后验概率 计算之前需要先定义，对应线的位置的方向 为此，使用以下等式将最接近视图的稀疏视点模型中的3D模型点和法向量投影到图像中：分别为位置和方向$$\\mathbf{c}_i &#x3D; \\mathbf{\\widetilde{\\pi } }(_C \\mathbf{T} _M \\space _M\\mathbf{\\widetilde{X}}_i)\\tag{26}$$ $$\\mathbf{n}_i \\propto (_C \\mathbf{R} _M \\space _M \\mathbf{N}i){2\\times1}\\tag{27}$$ 法向量$\\mathbf{n}_i$：被标准化为单位向量 $()_{2\\times1}$：表示向量的前两个元素 所有的对应线被定义后，我们能够变化当前姿势和关于姿势变换向量$\\theta$计算轮廓线$d_i$。然后轮廓距离可以通过对应线中心$c_i$到投影后的3D模型点（变为2D）的距离计算：$$d_i(\\mathbf{\\theta}) &#x3D; \\mathbf{n}_i^T(\\mathbf{\\pi}(_C \\mathbf{X}_i(\\mathbf{\\theta}))-\\mathbf{c}_i) \\tag{28}$$三维模型点$X_i$与定义对应线的三维模型点$X_i$相同 3D模型点$_C \\mathbf{X}_i$和轮廓距离$d_i$都依赖于当前姿势估计$_C \\mathbf{T} _M$,这会和用于定义对应线时的姿势不同 带有变化后的轮廓距离的轮廓线展示如下： (虚线是原点，虚线是基于姿势变换向量$\\theta$当前估计的轮廓线) 假设对应线独立，并使用离散化尺度空间（2.3节），联合后验概率被计算如下：$$p(\\mathbf{\\theta} \\space | \\space \\mathbf{D}) \\propto \\prod_{i&#x3D;1}^{n_c}p(d_{si}(\\mathbf{\\theta}) \\space | \\space \\omega {si},\\mathbf{l}{si})\\tag{29}$$ $\\mathbf{D}$描述所有对应线的数据 联合后验概率：描述了当前姿势估计将图像分割成前景区域（对应追踪目标）和后景区域的效果 3.4 Optimization目标：最大化联合后验概率 方法：估计变化向量$\\mathbf{\\tilde{\\theta}}$并迭代更新姿势 具体的计算（暂略） 结论： 正则化参数对应对应先验概率，控制了我们对先前的姿势（与梯度和Hessian描述的当前估计相比）的信任程度 对于Hessian表示高度不确定性的方向，正则化有助于保持优化稳定，并避免没有足够数据支持的位置变化 3.5 Gradient and Hessian Approximation梯度向量和Hessian矩阵的近似方式确保了快速收敛和高精度 为了计算对数后验函数所需的一阶和二阶导数，我们区分了全局优化和局部优化。我们提出了不同的局部优化近似方法，此外，我们要么应用全局优化，要么应用局部优化，并对所有对应线使用相同的导数定义，而不是混合使用 使用全局优化时，独立对应线的后验概率发布近似正态分布","categories":[{"name":"论文","slug":"论文","permalink":"http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"},{"name":"实验室","slug":"论文/实验室","permalink":"http://yoursite.com/categories/%E8%AE%BA%E6%96%87/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"}],"tags":[{"name":"3D Object","slug":"3D-Object","permalink":"http://yoursite.com/tags/3D-Object/"}]},{"title":"Volantis 第一次使用","slug":"Volantis-第一次使用","date":"2022-05-11T09:47:59.000Z","updated":"2022-05-11T16:17:33.155Z","comments":true,"path":"2022/05/11/Volantis-第一次使用/","link":"","permalink":"http://yoursite.com/2022/05/11/Volantis-%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Hello world！","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"AcWing算法基础课","slug":"算法/AcWing算法基础课","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"ML & DL","slug":"ML-DL","permalink":"http://yoursite.com/categories/ML-DL/"},{"name":"白板推导系列","slug":"ML-DL/白板推导系列","permalink":"http://yoursite.com/categories/ML-DL/%E7%99%BD%E6%9D%BF%E6%8E%A8%E5%AF%BC%E7%B3%BB%E5%88%97/"},{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"},{"name":"论文","slug":"论文","permalink":"http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"},{"name":"实验室","slug":"论文/实验室","permalink":"http://yoursite.com/categories/%E8%AE%BA%E6%96%87/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"ML","slug":"ML","permalink":"http://yoursite.com/tags/ML/"},{"name":"白板推导","slug":"白板推导","permalink":"http://yoursite.com/tags/%E7%99%BD%E6%9D%BF%E6%8E%A8%E5%AF%BC/"},{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"},{"name":"音乐","slug":"音乐","permalink":"http://yoursite.com/tags/%E9%9F%B3%E4%B9%90/"},{"name":"3D Object","slug":"3D-Object","permalink":"http://yoursite.com/tags/3D-Object/"}]}