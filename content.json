{"meta":{"title":"Kun's blog","subtitle":"","description":"","author":"Kun","url":"https://zwh1y.github.io","root":"/"},"pages":[{"title":"书单","date":"2022-05-08T11:27:13.405Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"https://zwh1y.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-05-08T11:27:13.387Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"about/index.html","permalink":"https://zwh1y.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2022-05-08T11:27:13.457Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"repository/index.html","permalink":"https://zwh1y.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-05-08T11:27:13.422Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"https://zwh1y.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-05-08T11:27:13.367Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"https://zwh1y.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-05-08T11:27:13.440Z","updated":"2022-03-21T07:18:46.000Z","comments":true,"path":"links/index.html","permalink":"https://zwh1y.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-08T11:27:13.475Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"tags/index.html","permalink":"https://zwh1y.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Latex测试","slug":"Latex测试","date":"2022-05-08T13:00:54.000Z","updated":"2022-05-08T13:19:27.384Z","comments":true,"path":"2022/05/08/Latex测试/","link":"","permalink":"https://zwh1y.github.io/2022/05/08/Latex%E6%B5%8B%E8%AF%95/","excerpt":"","text":"Lp=(∑i=1m∣xi−yi∣p)1pL_p = ( \\sum_ {i=1} ^m | x_i - y_i | ^ {p} ) ^ { { \\tfrac{1} {p} } } L​p​​=(​i=1​∑​m​​∣x​i​​−y​i​​∣​p​​)​​p​​1​​​​","categories":[{"name":"test","slug":"test","permalink":"https://zwh1y.github.io/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"https://zwh1y.github.io/tags/test/"}]},{"title":"SRT3D论文精读","slug":"SRT3D论文精读","date":"2022-05-08T12:20:13.000Z","updated":"2022-05-08T13:19:22.636Z","comments":true,"path":"2022/05/08/SRT3D论文精读/","link":"","permalink":"https://zwh1y.github.io/2022/05/08/SRT3D%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/","excerpt":"","text":"abstract： 基于区域的方法很火热，但是计算成本高，需求资源多。 我们提出了SRT3D可以减小效率上的差距 我们的模型认为图像信息会沿着对应线稀疏（correspondence lines），对应线会模拟物体的位置概率 引入smoothed step functions（平滑阶跃函数，西瓜书看到的翻译），用于考量定义的全局和局部的不确定性，对产生的概率公式进行分析 使用预渲染的稀疏视点模型（sparse viewpoint model）为对象姿势创建联合后验概率。 使用牛顿…优化 运行时间和质量比现有技术好，尤其是噪声和杂乱图像。 1 Introduction 计算机是觉得重要任务之一：跟踪三维空间中的刚体并预测其六自由度。在虚拟现实和机器人都有应用 给定连续的图像帧，3D目标追踪的目标是：估计对象相对于相机的旋转和平移。 概述现有技术、相关工作、我们的方法和贡献 1.1 3D Object Tracking 主流方法： 3D目标追踪 优点 缺点 key-points 应用广泛、最在不同阶段引入了深度学习 需要丰富的纹理（rich texture） explicit edges 提供格外的信息来源 在复杂场景容易失败（cluttered sccenes） direct optimization 优化了光度误差（photometric error） 需要丰富的纹理（rich texture） motion blur会改变纹理的边缘导致格外问题。 deep learning 使用CNNs考量完整图像信息，效果好 少数算法能够实时进行、每秒少于30帧、需要高端GPUs、耗时、需要有纹理的3D模型 depth information 使用深度相机（depth cameras）结合深度和RGB信息，总体可以得到更好的效果 很多应用中，不能使用深度传感器。 由于硬件、表面距离、表面特征和照明条件难以得到算法需要的高质量图像 image regions 在复杂场景中追踪对象、仅使用单目RGB相机和无纹理3D模型过去方法计算成本高，但是我们克服了这一缺点解决了动态模糊的问题，可以快速移动的物体 1.2 Related Work 基于区域的方法使用图像统计以区分目标所对应的前景和背景。 目标：找到最能展示图像分割的目标姿势以及轮廓。 潜力：挑战背景下，鲁棒追踪 最终，PWP3D将分割和追踪结合的方法以及像素级后验成员身份（ the pixel-wise posterior membership）结合，是使用水平集姿势的实时算法。它是几乎所有先进的基于区域的方法的基础。 大量算法对PWP3D进行了改进，如结合格外信息、拓展分割模型、提高效率、使用基于ICP的算法拓展能量函数、使用3D符号距离函数将藕和区域与深度信息结合到概率公式中、使用像素强度值或描述区域（descriptor fields）直接优化目标纹理、基于边缘的使用一个轮廓部分模型的技术。。。一直在介绍不同的技术，但是都只提一句话。 最后引入自己的技术 1.3 Contribution 我们致力于开发SRT3D，一种高效、稀疏的基于区域的跟踪方法。为了降低复杂性，我们使用区域信息和采用全局分割模型。我们在先前工作的基础上考虑沿对应线的稀疏图像信息，牛顿优化与Tikhonov正则化被用来估计对象的姿态。 我们的贡献： 对应线的形式定义和描述轮廓位置的概率模型数学推导 对全局和局部不确定性建模的新的平滑阶跃函数 参数对后验概率分布的影响 全局和局部优化策略以及局部一阶导数的新近似 之后先将对应线模型的建模，再将算法实现细节。我们的算法在RBOT和OPT上比现有技术效果和质量都更好 2. Correspondence Line Model 对应线的形式化数学定义 考虑将对应线分割为前景和背景的概率模型 拓展模型和提供离散比例公式 新的平滑阶跃函数以及其配置是如何影响轮廓位置的后验概率的 2.1 Correspondence Lines 我们考虑沿对应线稀疏地处理像素值（类似于ICP，先定义对应关系，再优化） 建立模型：根据传统的图像的定义建立对应线的定义，并表示出二者关系 \\mathbf {l} \\left (r \\right ) = I \\left ( \\mathbf {c} +r \\mathbf {n} \\right ) \\tag {1} 2.2 Probabilistic Model 提出了一个概率模型，用于将对应线分割为前景区域ωf\\omega_fω​f​​和背景区域ωb\\omega_bω​b​​。这相当于分割二维图像到区域 到Ωf\\Omega_fΩ​f​​和Ωb\\Omega_bΩ​b​​ 我们假定前景到背景只有一个过渡（translation），通过线中心（line center） c\\mathbf{c}c和相对（c\\mathbf{c}c）距离ddd 从对应线上的单个像素的形成开始推导，联合概率分布如下 p\\left(r, \\mathbf{y}, d, m\\right ) = p\\left (r\\space| \\space d, m\\right )p(\\mathbf{y} \\space |\\space m )p(m)p(d) \\tag{2} 符号解释： rrr：line coordinate（线坐标） y\\mathbf{y}y：image values（图像值）这里应该是单个像素的值 ddd：contour distance 相对于线中心ccc的距离 mmm：$m\\in \\left { m_f,m_b \\right } $ 表示前景或者背景的模型参数 将条件设置为yyy： p\\left(r, d, m \\space | \\space \\mathbf{y} \\right ) = p\\left (r\\space| \\space d, m\\right ) p(m\\space |\\space \\mathbf{y} ) p(d) \\tag{3} 推导过程： 由于P(X,Y)=P(X)P(X&nbsp;∣&nbsp;Y)P(X,Y) = P(X)P(X\\space |\\space Y)P(X,Y)=P(X)P(X&nbsp;∣&nbsp;Y) p(r&nbsp;∣&nbsp;d,m)p(y&nbsp;∣&nbsp;m)p(m)p(d)=p(y)p(r,d,m&nbsp;∣&nbsp;y)p\\left (r\\space| \\space d, m\\right )p(\\mathbf{y} \\space |\\space m )p(m)p(d) = p(\\mathbf{y} )p(r,d,m\\space |\\space \\mathbf{y} )p(r&nbsp;∣&nbsp;d,m)p(y&nbsp;∣&nbsp;m)p(m)p(d)=p(y)p(r,d,m&nbsp;∣&nbsp;y) $p(r,d,m\\space |\\space \\mathbf{y} ) = \\frac{p\\left (r\\space| \\space d, m\\right )p(\\mathbf{y} \\space |\\space m )p(m)p(d) }{p(\\mathbf{y} )} $ (y&nbsp;∣&nbsp;m)p(m)p(y)=p(m&nbsp;∣&nbsp;y)\\frac{(\\mathbf{y} \\space |\\space m )p(m) }{p(\\mathbf{y} )} = p(m \\space | \\space \\mathbf{y})​p(y)​​(y&nbsp;∣&nbsp;m)p(m)​​=p(m&nbsp;∣&nbsp;y) p(r,d,m&nbsp;∣&nbsp;y)=p(r&nbsp;∣&nbsp;d,m)p(m&nbsp;∣&nbsp;y)p(d)p\\left(r, d, m \\space | \\space \\mathbf{y} \\right ) = p\\left (r\\space| \\space d, m\\right ) p(m\\space |\\space \\mathbf{y} ) p(d)p(r,d,m&nbsp;∣&nbsp;y)=p(r&nbsp;∣&nbsp;d,m)p(m&nbsp;∣&nbsp;y)p(d) 得证 使用贝叶斯和边缘化覆盖mmm来计算像素级后验概率 p(y&nbsp;∣&nbsp;mf)p(\\mathbf{y} \\space |\\space m_f)p(y&nbsp;∣&nbsp;m​f​​)和p(y&nbsp;∣&nbsp;mb)p(\\mathbf{y} \\space |\\space m_b)p(y&nbsp;∣&nbsp;m​b​​)是概率分布，分别描述一个特定的颜色值属于前景区域或背景区域的可能性有多大。可以通过前景区域和后景区域的颜色分布直方图来计算（详见4.2） p(m_i \\space | \\space \\mathbf{y}) = \\frac{p(\\mathbf{y} \\space |\\space m_i)p(m_i)} { {\\textstyle \\sum_{j \\in \\{ f,b\\}}^{}}p(\\mathbf{y}\\space | \\space m_j )p(m_j) } , \\space i \\in \\{f, b\\} \\tag{4} 同样可以用P(X,Y)=P(X)P(X&nbsp;∣&nbsp;Y)P(X,Y) = P(X)P(X\\space |\\space Y)P(X,Y)=P(X)P(X&nbsp;∣&nbsp;Y)推出 沿对应线前景和背景的可能性相等p(mf)=p(mb)p(m_f) = p(m_b)p(m​f​​)=p(m​b​​) p(m_i \\space | \\space \\mathbf{y}) = \\frac{p(\\mathbf{y} \\space |\\space m_i)} {p(\\mathbf{y}\\space | \\space m_f )+p(\\mathbf{y}\\space |\\space m_b) } , \\space i \\in \\{f, b\\} \\tag{5} 基于（3），边缘化覆盖mmm和ddd在条件rrr下的后验概率 p(d \\space | \\space r ,\\mathbf{y} ) = \\frac{1}{p(r)} \\sum_{i \\in \\{f, b\\}}^{} p(r \\space |\\space d,m_i)p(m_i \\space |\\space \\mathbf{y} )p(d) \\tag{6} 为了计算整个对应线域ω\\omegaω上的后验概率，假设像素独立，基于（6） p(d \\space | \\space \\omega ,\\mathbf{l} ) \\propto \\prod_{r \\in \\omega}^{} \\sum_{i \\in \\{f, b\\}}^{} p(r \\space |\\space d,m_i)p(m_i \\space |\\space \\mathbf{l}(r) ) \\tag{7} p(r)p(r)p(r)和p(d)p(d)p(d)看作是常数所以删除 这是一个近似的假设，得到的结果十分接近真实值 条件线坐标概率p(r&nbsp;∣&nbsp;d,mi)p(r \\space |\\space d,m_i)p(r&nbsp;∣&nbsp;d,m​i​​)在2.4提到，这个概率模型描述了从图像中给定信息的形状内核（shape kernel）的概率 公式（7）提供了等高线距离数据与对应线的概率。 2.3 Discrete Scale-Space Formulation 复杂度 用途 $p(d \\space \\space \\omega ,\\mathbf{l} )$ quadratic（平方级）每一个d都要在整个域ω\\omegaω $p(m \\space \\space \\mathbf{y})$ linear（线性级） 从分布转变为像素级后验概率可以提高计算效率 此外，对对应线进行归一化处理也是有利的，可以确保指向一条对应线的线段中心的线坐标rrr指向所有对应线的线段中心。 （a line coordinate pointing to a segment center for one correspondence line points to a segment center for all correspondence lines） 我的理解：??? 这种统一的形式可以用于平滑步骤函数值的预计算，以进一步提高效率 基于先前的研究，我们将多个像素结合至线段中。离散空间尺度公式将沿对应线的连续空间投影至独立于对应线位置和方向的离散空间，如图3 同一个颜色表示一个segment（线段），蓝色和黄色的点表示segment的中心和对应的离散化后的值 偏移量∆r的选择要确保标度空间中的离散值对所有对应线都是一样的。在这个例子中，∆r指向像素之间最接近的边缘。 r_s = (r - \\Delta r) \\frac{\\overline{n} }{s} \\tag{8} d_s = (d - \\Delta r) \\frac{\\overline{n} }{s} \\tag{9} sss：合成为一段线段segment的像素比例（数量） n‾=max(∣nx∣,∣ny∣)\\overline{n} = max (|n_x|,|n_y|)​n​​​=max(∣n​x​​∣,∣n​y​​∣)：将对应线投影到最近的水平或垂直图像坐标的主要的绝对法向分量 Δr∈R\\Delta r \\in RΔr∈R：从对应线中心ccc到定义的像素位置的距离（c所在的像素相邻两个像素中，c更接近的那个边缘到c的距离） 我的理解： 根据之前的内容的上述公式，以及d的定义：d是相对于中心点c的距离。我们可以理解为：假设r（line coordinate）为距离中心点c的距离。 这里就可以很好的解释r/dsr/d_sr/d​s​​减去偏移量Δr\\Delta rΔr乘以n‾s\\frac{\\overline{n}}{s}​s​​​n​​​​​这一映射关系 例如：图示的s为2（两个像素构成一个segment），n‾\\overline{n}​n​​​为nxn_xn​x​​（对应线距离水平线投影更近）。从最右边的黄色点来看，减去偏移量后，即r−Δrr - \\Delta rr−Δr为3个单位像素（线坐标下），nxn_xn​x​​为3，n‾s\\frac{\\overline{n}}{s}​s​​​n​​​​​为1.5，那么对应到rsr_sr​s​​中，坐标即为1.5如图所示。 根据公式（7），离散尺度空间中的后验概率计算如下： p(d_s \\space | \\space \\omega_s ,\\mathbf{l}_s ) \\propto \\prod_{r_s \\in \\omega_s}^{} \\sum_{i \\in \\{f, b\\}}^{} p(r_s \\space |\\space d_s,m_i)p(m_i \\space |\\space \\mathbf{l_s}(r_s) ) \\tag{10} ωs\\omega_sω​s​​：放缩后到对应线域 s=ls(rs)\\mathbf{s} = \\mathbf{l}_s(r_s)s=l​s​​(r​s​​)：一个集值函数映射，它从按比例排列的线坐标映射到线段sss，这是一个最接近sss(和上文是一个意思)像素值yyy的集合 类似于公式（5），我们假设像素间具有独立性，分段后验可以被定义为： p(m_i \\space | \\space \\mathbf{s}) = \\frac{\\prod_{\\mathbf{y} \\in \\mathbf{s} }p(\\mathbf{y} \\space |\\space m_i)} {\\prod_{\\mathbf{y} \\in \\mathbf{s} }p(\\mathbf{y}\\space | \\space m_f )+ \\prod_{\\mathbf{y} \\in \\mathbf{s} }p(\\mathbf{y}\\space |\\space m_b) } ,\\space i \\in \\{f, b\\} \\tag{11} 这个推导公式，允许使用放缩参数sss设置线段尺寸和调整准确性和效率之间的取舍，来有效覆盖对应线域ω\\omegaω （之后的公式省略了下标s，但是定义和推导对原始空间和离散化空间都有效） 2.4 Smoothed Step Functions 目标：对线坐标的条件概率p(r∣d,mf)p(r|d, m_f)p(r∣d,m​f​​)p(r∣d,mb)p(r|d, m_b)p(r∣d,m​b​​)进行建模，因此提出了不同的平滑阶跃函数hfh_fh​f​​和hbh_bh​b​​ 先前的工作：验证了双曲正切曲线会导致后验概率p(d∣ω,l)p(d|\\omega , l)p(d∣ω,l)的高斯分布 作用：平滑斜率用于模拟与前景和背景过渡的确切位置有关的局部不确定性 错误的假设：给一个模型mmm和轮廓距离ddd，我们就可以根据hhh函数预测线坐标rrr属于轮廓线的哪一边，但是在实际应用中是错误的 存在的问题： 1. 等式（5）仍是对真实世界的不完美简化 1. 统计模型未考虑图像噪声或快速外观变化，这可能导致颜色直方图中尚未出现的像素颜色 1. 由于不完美的分割而被错误分类的像素，然后被分配到错误的颜色直方图 1. 一个纯粹依赖像素颜色的统计模型是否足以捕捉现实世界中的所有统计效果，并且能够完美地预测模型$m$ 将上述问题考虑以及前景后景建模的恒定的全局不确定性 h_f(x)=\\frac{1}{2}-\\alpha _h tanh \\left (\\frac{x}{2s_h} \\right ) \\tag{12} h_b(x)=\\frac{1}{2}+\\alpha _h tanh \\left (\\frac{x}{2s_h} \\right ) \\tag{13} 振幅参数αh∈[0,0.5]\\alpha _h \\in \\left[0,0.5 \\right]α​h​​∈[0,0.5]添加到仅考虑坡度参数sh∈R+s_h \\in R^{+}s​h​​∈R​+​​的原始定义中 对于α\\alphaα的另一种解释： 我们假设模型mmm扩展第三类mnm_nm​n​​，该类mnm_nm​n​​考虑独立于前景ωf\\omega _fω​f​​和后景ωb\\omega _bω​b​​的外部影响。对于这个场景，我们可以证明$p(m_f) =p(m_b)=\\alpha 和p(m_n)=1-2\\alpha$。 根据这种解释，振幅参数因此允许我们设置一个像素的颜色由前景或背景模型生成的概率，与其他一些被视为噪声的影响形成对比。 这再次表明，振幅参数α能够模拟恒定的全局不确定性。 请注意，在这种情况下，收敛到0或1的原始平滑阶跃函数用于计算p(r∣d,mf)p(r|d,m_f)p(r∣d,m​f​​)和p(r∣dm)p(r|d_m)p(r∣d​m​​)，而噪声模型采用恒定函数p(r∣d,mn)=12p(r|d,m_n)=\\frac{1}{2}p(r∣d,m​n​​)=​2​​1​​。 附录A中给出了该扩展模型的详细推导及其与等式（12）和（13）中函数使用等价性的证明。 2.5 Posteior Probability Distrubution 考虑到平滑阶跃函数h_f和h_b建立了条件线坐标概率模型p(r | d,m_f)和p(r | d,m_b)，则等式（7）中后验概率分布的最终表达式可以写成 p(d \\space | \\space \\omega ,\\mathbf{l} ) \\propto \\prod_{r \\in \\omega}^{} h_f(r-d)p_f(r) + h_b(r-d)p_b(r) \\tag{14} 缩写：p_f(r)=p(m_f \\space |\\space \\mathbf{l}(r))和p_b(r)=p(m_b \\space |\\space \\mathbf{l}(r)) 假设轮廓在对应线中心和像素级后验概率p_f和p_b的阶跃函数 阶跃函数的假设很好地反映了现实世界中的实验，实验表明，在大多数情况下，前景和后景之间存在明显的分离 对公式取对数并关于ddd求一阶导，假设具有无穷小像素的连续函数。基于附录B，封闭解如下： \\frac{\\partial ln(p(d \\space | \\space \\omega, \\mathbf{l} ))}{\\partial d} = -2tanh^{-1}\\left ( 2 \\alpha _h tanh \\left ( \\frac{d}{2s_h} \\right )\\right ) \\tag{15} 满足αh=12\\alpha _h=\\frac{1}{2}α​h​​=​2​​1​​和sh→0s_h \\to 0s​h​​→0两种情况时，公式（15）可以简化，我们能计算后验概率分布的闭式解。 αh=12\\alpha _h=\\frac{1}{2}α​h​​=​2​​1​​时，我们获得了我们之前方法的平滑阶跃函数，公式（12）（13），后验概率分布会产生完美的高斯分布 p(d \\space | \\space \\omega ,\\mathbf{l} ) = \\frac{1}{\\sqrt[]{2\\pi s_h} }exp\\left ( -\\frac{d^2}{2s_h} \\right ) \\tag{16} 其中斜率参数shs_hs​h​​等于方差。在sh→0s_h \\to 0s​h​​→0的情况下，这导致了hfh_fh​f​​和hbh_bh​b​​的尖锐阶梯函数，后验概率分布成为一个完美的拉普拉斯分布 p(d \\space | \\space \\omega ,\\mathbf{l} ) = \\frac{1}{2b} exp\\left ( -\\frac{|d|}{b\\ } \\right ) , b=\\frac{1}{2tanh^-1(2 \\alpha _h)} \\tag{17} 附录C中有详细推导 ![image-20220424142755366](/Users/mac/Library/Application Support/typora-user-images/image-20220424142755366.png) 拉普拉斯分布（蓝色）有明显的峰值，高斯分布（黄色）有一个平滑的最大值，附近的值有类似的高概率 从图像中可以知道，shs_hs​h​​控制局部不确定性（大量的值d可能等于多少），αh\\alpha _hα​h​​控制全局不确定性（控制与周围环境相比的峰值大小） 3. Region-Based 3D Tracking 内容： 定义数学概念 对稀疏视点模型的描述，这个模型避免了在跟踪过程中对三维模型的渲染 将这种几何学表示与对应线模型结合，制定出与姿势有关的联合后验概率 该概率通过牛顿优化和Tikhonov正则化实现最大化。 我们为牛顿方法定义所需的梯度向量和Hessian矩阵。因此，我们区分了全局和局部优化，以确保快速融合和高精确度。 3.1 Preliminaries 前言 定义：3D模型点X=[X&nbsp;Y&nbsp;Z]T∈R3\\mathbf{X} = [X \\space Y \\space Z]^{T}\\in R^{3}X=[X&nbsp;Y&nbsp;Z]​T​​∈R​3​​ 其次形式：\\widetilde{\\mathbf{X}} = [X \\space Y \\space Z \\space 1]^{T}\\in R^{3} 齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示，是指一个用于投影几何里的坐标系统，如同用于欧氏几何里的笛卡儿坐标一般 引入齐次坐标可以让放缩变换变得更加统一简单。例如：平移是矩阵加法，而升维之后可以用矩阵乘法实现 对于3D模型点X\\mathbf{X}X向图像空间的投影，我们假设图像不失真，并使用针孔相机模型 x = \\pi (\\mathbf{X} )=\\begin{bmatrix} \\frac{X}{Z}f_x + p_x \\\\ \\frac{X}{Z} f_y + p_y \\end{bmatrix} \\tag{18} 焦距f_x和f_y、关键点（principal point）p_x和p_y是像素级的 xxx：图像坐标 反转：从图像坐标xxx和对应深度值dZd_Zd​Z​​沿光轴重建为3D模型点 光轴是光学系统中一条假想的线，定义（在一次近似下）光学系统如何传导光线 \\mathbf{X}=\\pi^{-1}(x, d_Z)=d_Z\\begin{bmatrix} \\frac{x-p_x}{f_x} \\\\ \\frac{y-p_y}{f_y} \\\\ 1 \\end{bmatrix} \\tag{19} 使用齐次矩阵CTM∈SE(3)_{C}T _M \\in SE(3)​C​​T​M​​∈SE(3)描述相机参考系C和模型参考系M之间的相对姿态 SE(3) 是旋转加上位移， 也称欧式变换（Euclidean transformation），刚体变换（Rigid Transformation），一般我们用矩阵 来表示，其中 为旋转， t 为位移，所以有6个自由度，3个旋转，3个位置。 对于一个三维模型点的变换，我们可以写出： _{C} \\widetilde{X} = _{C}T _{MM} \\widetilde{X}=\\begin{bmatrix} _{C}R_M&amp; -{C}t_M \\\\ 0 &amp; 1 \\end{bmatrix} \\space _{M}\\widetilde{X} \\tag{20} _{C} \\widetilde{X}和$ \\space _{M}\\widetilde{X}$ 分别是写入相机C和参考系模型参考系M中的3D模型点 $ _{C}R_M和-{C}t_M$是旋转矩阵和平移向量，定义从M到C的转换 对于小的变化，使用角轴表示，这是一个最小的表示。 用指数映射，旋转矩阵写为 \\mathbf{R} = exp([\\mathbf{r}]_\\times)=\\mathbf{I} + [\\mathbf{r}]_\\times + \\frac{1}{2!}[\\mathbf{r}]_\\times^{2}+ \\frac{1}{3!}[\\mathbf{r}]_\\times^{3}+... \\tag{21} [r]×[\\mathbf{r}]_\\times[r]​×​​是斜对称矩阵,r∈R3\\mathbf{r} \\in R^3r∈R​3​​ 忽略级数展开的高阶项，等式（21）可以线性化。然后，我们可以在相机参考系C中写入3D模型点的线性变化，如下所示： _C\\widetilde{X}(\\theta) = \\begin{bmatrix} _CR_M&amp; Ct_M\\\\ 0&amp;1 \\end{bmatrix} \\begin{bmatrix} \\mathbf{I} + [\\theta_r]_\\times &amp; \\theta _t \\\\ 0 &amp; 1 \\end{bmatrix} \\space _M \\widetilde{X} \\tag{22} θr∈R3\\theta_r \\in R^3θ​r​​∈R​3​​ ：旋转变换 θt∈R3\\theta _t \\in R^3θ​t​​∈R​3​​：平移变换 θT=[θrT,θtT]\\theta ^T=[\\theta _r^T,\\theta _t^T]θ​T​​=[θ​r​T​​,θ​t​T​​]：完变换向量 改变模型参考系M的优点： 由于对象的移动量通常比相机的移动量大得多，会更加自然 使==拓展为使用多相机算法==成为可能 3.2 Sparse Viewpoint Model 为了创建这个模型，三维几何体从物体周围的若干nvn_vn​v​​视点进行渲染 虚拟摄像机被放置在围绕物体的测地网格的顶点上 对于每一个渲染，n_c个点 \\mathbf{x_i} \\in R^2从模型轮廓上随机采样（2D上） 单位向量ni∈R2\\mathbf{n_i} \\in R^2n​i​​∈R​2​​近似垂直于每个点（法向量） 基于2D实体，关于模型参考系，3D向量被重建： _M \\mathbf{\\widetilde{X} }_i = _{M}T _C \\mathbf{\\widetilde{\\pi } }^{-1}(x_i,d_{Zi}) \\tag{23} _M \\mathbf{N}_i = _M\\mathbf{R}_C \\begin{bmatrix} \\mathbf{n} _i \\\\ 0 \\end{bmatrix} \\tag{24} \\mathbf{ \\widetilde{\\pi }}^{-1}：表示三维模型点以齐次形式返回（他可以将x和d_Z（图像值和深度）映射为3D模型点 ） dZid_{Zi}d​Zi​​：渲染产生的深度值 CCC：表示虚拟摄像机的，参考系渲染就是从这里开始的 Mv=MRCeZ_M\\mathbf{v}=_M \\mathbf{R}_C \\mathbf{e}_Z​M​​v=​M​​R​C​​e​Z​​：方向向量，从摄像机指向模型中心eZ=[001]T\\mathbf{e}_Z=\\begin{bmatrix} 0 &amp; 0 &amp; 1 \\end{bmatrix}^Te​Z​​=[​0​​​0​​​1​​]​T​​ 计算的3D模型点、法向量、方向向量会被存储到每一个视图中 给定特定的姿势（_M\\mathbf{R}_C和 _C\\mathbf{t}_M），渲染模型和计算轮廓的过程简化为找到最接近的预计算视图ivi_vi​v​​： i_v = \\underset{i \\in {1,...n_v}}{arg \\space max}(_M \\mathbf{v}_i^{T}\\space _M \\mathbf{R}_C \\space _C \\mathbf{t} _M ) \\tag{25} 然后将相应的3D模型点和法向量投影到图像中 请注意，在优化关节后验概率时，这种高效率尤其重要，因为每次迭代中姿势都会发生变化。 3.3 Joint Posterior Probability 结合稀疏视点模型与对应线模型，定义关于姿势变换的联合后验概率 计算之前需要先定义，对应线的位置的方向 为此，使用以下等式将最接近视图的稀疏视点模型中的3D模型点和法向量投影到图像中：分别为位置和方向 \\mathbf{c}_i = \\mathbf{\\widetilde{\\pi } }(_C \\mathbf{T} _M \\space _M\\mathbf{\\widetilde{X}}_i) \\tag{26} \\mathbf{n}_i \\propto (_C \\mathbf{R} _M \\space _M \\mathbf{N}_i)_{2\\times1} \\tag{27} 法向量ni\\mathbf{n}_in​i​​：被标准化为单位向量 ()2×1()_{2\\times1}()​2×1​​：表示向量的前两个元素 所有的对应线被定义后，我们能够变化当前姿势和关于姿势变换向量θ\\thetaθ计算轮廓线did_id​i​​。然后轮廓距离可以通过对应线中心cic_ic​i​​到投影后的3D模型点（变为2D）的距离计算： d_i(\\mathbf{\\theta}) = \\mathbf{n}_i^T(\\mathbf{\\pi}(_C \\mathbf{X}_i(\\mathbf{\\theta}))-\\mathbf{c}_i) \\tag{28} 三维模型点XiX_iX​i​​与定义对应线的三维模型点XiX_iX​i​​相同 3D模型点CXi_C \\mathbf{X}_i​C​​X​i​​和轮廓距离did_id​i​​都依赖于当前姿势估计CTM_C \\mathbf{T} _M​C​​T​M​​,这会和用于定义对应线时的姿势不同 带有变化后的轮廓距离的轮廓线展示如下： (虚线是原点，虚线是基于姿势变换向量θ\\thetaθ当前估计的轮廓线) 假设对应线独立，并使用离散化尺度空间（2.3节），联合后验概率被计算如下： p(\\mathbf{\\theta} \\space | \\space \\mathbf{D}) \\propto \\prod_{i=1}^{n_c}p(d_{si}(\\mathbf{\\theta}) \\space | \\space \\omega _{si},\\mathbf{l}_{si}) \\tag{29} D\\mathbf{D}D描述所有对应线的数据 联合后验概率：描述了当前姿势估计将图像分割成前景区域（对应追踪目标）和后景区域的效果 3.4 Optimization 目标：最大化联合后验概率 方法：估计变化向量θ~\\mathbf{\\tilde{\\theta}}​θ​~​​并迭代更新姿势 具体的计算（暂略） 结论： 正则化参数对应对应先验概率，控制了我们对先前的姿势（与梯度和Hessian描述的当前估计相比）的信任程度 对于Hessian表示高度不确定性的方向，正则化有助于保持优化稳定，并避免没有足够数据支持的位置变化 3.5 Gradient and Hessian Approximation 梯度向量和Hessian矩阵的近似方式确保了快速收敛和高精度 为了计算对数后验函数所需的一阶和二阶导数，我们区分了全局优化和局部优化。我们提出了不同的局部优化近似方法，此外，我们要么应用全局优化，要么应用局部优化，并对所有对应线使用相同的导数定义，而不是混合使用 使用全局优化时，独立对应线的后验概率发布近似正态分布","categories":[{"name":"论文","slug":"论文","permalink":"https://zwh1y.github.io/categories/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"slam","slug":"slam","permalink":"https://zwh1y.github.io/tags/slam/"},{"name":"目标检测","slug":"目标检测","permalink":"https://zwh1y.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"目标追踪","slug":"目标追踪","permalink":"https://zwh1y.github.io/tags/%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA/"}]},{"title":"AcWing算法基础课笔记","slug":"AcWing算法基础课笔记","date":"2022-05-08T06:40:53.000Z","updated":"2022-05-08T06:44:22.173Z","comments":true,"path":"2022/05/08/AcWing算法基础课笔记/","link":"","permalink":"https://zwh1y.github.io/2022/05/08/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第一讲 基础算法 主要思想：代码为什么是对的、为什么这样写，需要有一个深刻的理解。 课后： 背过代码（快速的默写出模版，调试之后能过） 课后习题 （）每个题目写个3-5遍 1. 快速排序（已过） 思想：基于分治 快速排序 ![image-20220210144232572](/Users/mac/Library/Application Support/typora-user-images/image-20220210144232572.png) 思想： 确定分界点：q[l] q[r] q[l + r &gt;&gt; 1] 调整区间：x左边的数都小于等于x， x右边的数都大于等于x 递归处理左右两段 复习出现的错误： do while循环不熟练，do后面的i++也需要加上； 递归处理的时候越界了，写的分界点是j-1和j？？？（暂时不知道为什么）经过测试，使用i-1和i分界也会出错，使用 + 1就不会。 x = l + r &gt;&gt; 1出错，如果我们不使用x = q[l + r &gt;&gt; 1]。这里如果每次记住的是下标，那么每次都是那个固定的下标，然而下标的固定并不能保证下标里面存放的值是固定的，尤其是在进行swap交换的过程中，可能会出现对应的值发生了变化，如果此时坚持使用q[下标] 当下标对应的位置改变的时候q[下标]第k个数也会改变，但是我们选点的时候是根据一个固定的值，左边全部小于等于x右边全部大于等于x。违背了这个初衷就会WA 我们每次while循环需要用同一个值来进行比较，如果保存下标的话，在交换后可能导致同一个while循环中比较的数改变，从而造成错误。 ![image-20220309091843756](/Users/mac/Library/Application Support/typora-user-images/image-20220309091843756.png) Sl和Sr表示的是个数 重点思想： 多了一个k，排序之后，通过左边的数和右边数的个数辅助判断 2. 归并排序 思想：基于分治 归并排序 ![image-20220210151729930](/Users/mac/Library/Application Support/typora-user-images/image-20220210151729930.png) 思想： 确定分界点：mid = (l + r) &gt;&gt; 2 和快速排序的区别是快速排序是数组中的值，而这里用的是下标 递归排序 left right 归并 合并两个有序的数组 代码实现： 递归终止情况 分成子问题，递归处理子问题 合并子问题 123456789101112131415161718192021void merge_sort(int q[], int l, int r){ //递归的终止情况 if(l &gt;= r) return; //第一步：分成子问题 int mid = l + r &gt;&gt; 1; //第二步：递归处理子问题 merge_sort(q, l, mid ), merge_sort(q, mid + 1, r); //第三步：合并子问题 int k = 0, i = l, j = mid + 1, tmp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) if(q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while(i &lt;= mid) tmp[k++] = q[i++]; while(j &lt;= r) tmp[k++] = q[j++]; for(k = 0, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];} 边界分析： 为什么不用 mid - 1 作为分隔线呢？ 即 merge_sort(q, l, mid - 1 ), merge_sort(q, mid, r) 因为 mid = l + r &gt;&gt; 1 是向下取整，mid 有可能取到 l (数组只有两个数时)，造成无限划分 解决办法: mid 向上取整就可以了, 即 mid = l + r + 1 &gt;&gt; 1,如下所示: 逆序对的数量 3. 二分 二分的本质是二段性 有单调性一定可以二分，没有单调性也有可能可以二分 重点： 1. check需要自己定义去找一个最合适的 数的范围 ![image-20220327204537182](/Users/mac/Library/Application Support/typora-user-images/image-20220327204537182.png) ![image-20220327224242273](/Users/mac/Library/Application Support/typora-user-images/image-20220327224242273.png) ![image-20220210160017818](/Users/mac/Library/Application Support/typora-user-images/image-20220210160017818.png) 图示如下： ![image-20220315221453548](/Users/mac/Library/Application Support/typora-user-images/image-20220315221453548.png) ![image-20220315210734201](/Users/mac/Library/Application Support/typora-user-images/image-20220315210734201.png) mid = l + r + 1&gt;&gt; 1 找小于等于x的数，判断 mid &lt;= x是否成立 if(check(mid)) true [mid, r] 更新：l = mid ​ false [l, mid - 1] 更新：r = mid - 1 ![image-20220315211523555](/Users/mac/Library/Application Support/typora-user-images/image-20220315211523555.png) mid = l + r &gt;&gt; 1 找大于等于x的数，判断mid &gt;= x是否成立 if(check(mid)) true [l, mid] 更新：r = mid ​ false[mid + 1, r] 更新：l = mid + 1 是否加1:看更新区间，如果是l = mid就需要补一个 + 1，如果是r=mid就不需要补上+ 1。 如何理解mid +1还是-1: 判断q[mid] &gt;= x，不满足的话，mid就不会在区间内,更新后的区间要靠近r，所以要让 l = mid + 1 判断q[mid] &lt;= x，不满足的话，mid就不会在区间内,更新后的区间要靠近l，所以要让 r = mid - 1 浮点数二分 浮点数二分，没有精度问题，好写 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main(){ double x; cin &gt;&gt; x; double l = 0, r = x; while(r - l &gt; 1e-8){ // 精度提高，比输出多2就没问题 double mid = (l + r)/2; if(mid*mid &gt;= x) r = mid; else l = mid; } printf(\"%lf\\n\", l); return 0;} 循环写法(区间变为原来的100分之一) 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main(){ double x; cin &gt;&gt; x; double l = 0, r = x; for(int i = 0; i &lt; 100; i++){ double mid = (l + r)/2; if(mid*mid &gt;= x) r = mid; else l = mid; } printf(\"%lf\", l); return 0;} 4. 高精度 c++需要 java中有大整数类 python默认是无限大 A &lt;= 10与len(A) &lt; 10 0-9999999999 都是使用大数组进行存储 处理中使用到了A[i] - ‘0’（自动转换为ASCII码的值相减）相减得到的就是数值 高精度加法 大数组存储 模拟人工加法的过程 每次计算的时候使用到了三个数Ai Bi 以及 t（进位） 使用数组表示A B C（使用vector数组就可以不需要额外使用变量来获取长度） 使用一个t来表示进位 高精度减法 ![image-20220212143839690](/Users/mac/Library/Application Support/typora-user-images/image-20220212143839690.png) 需要保证 A &gt;= B, 如果A &lt;B，则计算B-A加上一个负号 设计到负数就使用绝对值计算出再进行符号判断 t表示是当前位数的数值，以及用来判断是否借位（取值为1或者0） 注意：去掉前导0（除非数值为0） 高精度乘法 与高精度加法类似，利用到t来计算进位 高精度除法 5. 前缀和与差分（其实是一对逆运算） 前缀和 注意： 就是算出前n项和，比较简单 题目一遍问的是第几个数到第几个数，所以从1开始会比较好理解，不容易出错。 ![image-20220212194305121](/Users/mac/Library/Application Support/typora-user-images/image-20220212194305121.png) 子矩阵的和 注意： 输出的计算：s[x2][y2] - s[x2][y1 - 1] -s[x1 - 1][y2] + s[x1 - 1][y1 - 1] ![image-20220214104150816](/Users/mac/Library/Application Support/typora-user-images/image-20220214104150816.png) 差分（不需要考虑如何构造，只要考虑如何） 差分数组是一个数组 存放的是相邻数据之间的差值 假象一个b数组，b的前缀和是a，b被称为a的差分 用处：O(1)的时间解决原来O(n)的问题 假定a1 - an都是0，差分数组也就是都是0，假定插入了n次插入操作，每次让原数组[n, n]的区间插入a[n]：插入操作操作就可以直接使用到公式（在原数组a的一段区间中插入值）： 1234void insert(int l, int r, int c){ b[l] += c; b[r + 1] -= c;} ![image-20220214113403124](/Users/mac/Library/Application Support/typora-user-images/image-20220214113403124.png) ![image-20220214113811487](/Users/mac/Library/Application Support/typora-user-images/image-20220214113811487.png) 差分矩阵（二维差分） 令aij等于0，显然bij等于零，再根据aij实际值，插入一遍就好了 公式： 123456void insert(int x1, int y1, int x2, int y2, int c){ b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -=c; b[x2+1][y2+1] +=c;} ![image-20220214155746725](/Users/mac/Library/Application Support/typora-user-images/image-20220214155746725.png) 6. 双指针算法 **核心思想：**将一个复杂度更高的计算，优化 ![image-20220318204523962](/Users/mac/Library/Application Support/typora-user-images/image-20220318204523962.png) 两大类： 归并排序 快速排序 j表示j往左，最左能到什么地方 先写下面的模版，再如何去做 12345for(i=0, j=0; i&lt;n; i++){ while(j &lt; i &amp;&amp; check(i, j)) j++; // 每道题的具体逻辑} 核心思想： 通过暴力先写暴力做法 在枚举的时候看，i和j的单调关系 利用单调关系把枚举数量从n^2变成n 1234for(int i = 0; i &lt; n; i++) for(int j = 0; j&lt; n; j++) O(n^2)// 将上面的朴素算法优化到O(n) 简单的例题：将每个单词分别输出且各占一行。 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main(){ char str[1000]; gets(str); int n = strlen(str); for(int i = 0; str[i]; i++){ int j = i; while(j &lt; n &amp;&amp; str[j] != ' ') j++; // 这道题的具体逻辑 for(int k = i; k &lt; j; k++) cout &lt;&lt; str[k]; cout &lt;&lt; endl; i = j; }} 最长连续不重复子序列 核心思路： 遍历数组a中的每一个元素a[i], 对于每一个i，找到j使得双指针[j, i]维护的是以 a[i]结尾 的最长连续不重复子序列，长度为i - j + 1, 将这一长度与r的较大者更新给r。 对于每一个i，如何确定j的位置：由于[j, i - 1]是前一步得到的最长连续不重复子序列，所以如果[j, i]中有重复元 素，一定是a[i]，因此右移j直到a[i]不重复为止（由于[j, i - 1]已经是前一步的最优解，此时j只可能右移以剔除重复元素a[i]，不可能左移增加元素，因此，j具有“单调性”、本题可用双指针降低复杂度）。 用数组s记录子序列a[j ~ i]中各元素出现次数，遍历过程中对于每一个i有四步操作：cin元素a[i] -&gt; 将a[i]出现次数s[a[i]]加1 -&gt; 若a[i]重复则右移j（s[a[j]]要减1） -&gt; 确定j及更新当前长度i - j + 1给r。 注意细节： 当a[i]重复时，先把a[j]次数减1，再右移j。 ![image-20220216145058032](/Users/mac/Library/Application Support/typora-user-images/image-20220216145058032.png) 暴力：遍历起点和终点(i在右边，j在左边) 12345678// 朴素做法： O(n^2)for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt;= i; j++){ if(check(i, j)){ res = max(res, i - j + 1); } }} 双指针算法： 找到单调性等新的性质，简化时间复杂度 1234for(int i = 0， j = 0; i &lt; n; i++){ while(j &lt;= i &amp;&amp; check(j, i)) j++; res = max(res, i - j + 1);} 数组元素的目标和 判断子序列 7. 位运算 n的二进制表示中第k位是几（个位是第0位） 先把第k位移到最后一位 n &gt;&gt; k 看各位是几 x&amp;1 结合1、2之后，常用操作：n &gt;&gt; k &amp; 1 lowbit(x)：返回x的最后一位1 ![image-20220216162301007](/Users/mac/Library/Application Support/typora-user-images/image-20220216162301007.png) x = 1010 lowbit(x) = 10(2) x = 101000 lowbit(x) = 1000(4) 实现原理：x&amp;-x -x = ~x + 1所以x&amp;-x = x&amp;(~x+1) 二进制中1的个数(上述应用) ![image-20220216162952102](/Users/mac/Library/Application Support/typora-user-images/image-20220216162952102.png) 8. 离散化（整数有序） 值域很大，但是内容稀疏 将下标离散化 ![image-20220227143216831](/Users/mac/Library/Application Support/typora-user-images/image-20220227143216831.png) 区间和 将下标离散化之后，离散化之后的下标插入对应的值，同时离散化的下标包括查找的区间，形成一个新的数组进行处理。 ![区间和](/Users/mac/Library/Application Support/typora-user-images/区间和.jpg) ![image-20220216165051104](/Users/mac/Library/Application Support/typora-user-images/image-20220216165051104.png) 将下标拿过来排序，映射到从1开始的自然数，利用前缀和计算 给x加c 找x离散化之后的数是多少 L,R 也会放到离散化的容器中，这样可以方便找到需要求的值 unique实现： 它是第一个数 它和前一个数不一样，即：a[i] != a[i-1] ![image-20220217151011007](/Users/mac/Library/Application Support/typora-user-images/image-20220217151011007.png) 9. 区间合并 区间合并 ![image-20220217152352262](/Users/mac/Library/Application Support/typora-user-images/image-20220217152352262.png) 按左端点排序 存在三种情况，分别来看如何对区间进行更新（由于已经排序且是从左到右进行扫描，因此左端点不可能在目前区间左边） 在目前的区间内 左端点在区间内，右端点在区间外 左端点在区间外 第二讲 数据结构 链表与邻接表 栈与队列 kmp 使用数组模拟链表：快（静态列表） 单链表：用来写邻接表（存储图和树） 双链表：优化某些问题 单链表 head指向尾节点（的下标-1 ！！！） ![image-20220222163913219](/Users/mac/Library/Application Support/typora-user-images/image-20220222163913219.png) 双链表 我认为需要加强印象的点： 初始化，idx 0 和 1，互相指，和单链表不同的是使用循环来判断是否是尾节点，就只要看是不是指向 idx = 1(原来好像就可以理解为idx -1。。。这么一想似乎是之前的认知出现问题了) 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int N = 100010;int m;int e[N], l[N], r[N], idx;// 初始化void init(){ // 0表示左端点，1表示右端点 r[0] = 1, l[1] = 0; idx = 2;}// 在下标是k的右边插入一个数void add(int k, int x){ e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; // 可以使用r[idx]这样就可以忽略顺序了 r[k] = idx;}void remove(int k){ r[l[k]] = r[k]; l[r[k]] = l[k];} 栈 1234567891011121314int stk[N], tt; // tt表示栈顶下标// 插入skt[++tt] = x;// 弹出tt--;// 判断栈是否为空if(tt &gt; 0) not emptyelse empty// 栈顶stk[tt] 队列 1234567891011121314// 队尾插入元素，队头弹出元素int q[N], hh, tt = -1;// 插入q[++tt] = x;// 弹出hh++;// 判断队列是否为空if(hh &lt;= tt) not empty;else empty;//取出队头元素q[hh] 单调栈 暴力做法 挖掘性质 找到某种状态 达到降低复杂度的方法 如果要放进去的数比栈里面的数都要小（对于新的一个数进行判断的时候，肯定更加靠近新的数，而且更小），那栈里面的数都不不可能会输出，即用不到（没必要存储） ![image-20220222220923613](/Users/mac/Library/Application Support/typora-user-images/image-20220222220923613.png) 构建一个栈用于存储i左边的所有元素 单调队列（滑动窗口） 和单调栈类似： 只要后面有一个元素比前面的元素还要小，那么前面的就可以丢弃（之后肯定是选择后面这个更小的数） 思路： ![image-20220320181500910](/Users/mac/Library/Application Support/typora-user-images/image-20220320181500910.png) ![image-20220320181308549](/Users/mac/Library/Application Support/typora-user-images/image-20220320181308549.png) 最小值和最大值分开来做，两个for循环完全类似，都做以下四步： 解决队首已经出窗口的问题; 解决队尾与当前元素a[i]不满足单调性的问题; 将当前元素下标加入队尾; 如果满足条件则输出结果; 需要注意的细节： 上面四个步骤中一定要先3后4，因为有可能输出的正是新加入的那个元素; 队列中存的是原数组的下标，取值时要再套一层，a[q[]]; 算最大值前注意将hh和tt重置; 此题用cout会超时，只能用printf; hh从0开始，数组下标也要从0开始。 KMP 实现思路： 暴力算法怎么做 如何去优化 12345678910111213S[N], P[M];for (int i = 1; i &lt;= n; i ++ ){ bool flag = true; for (int j = 1; j &lt;= m; j ++ ) { if (s[i + j - 1] != p[j]) { flag = false; break; } }} 预处理：后缀与前缀相等（最少移动多少又能继续匹配到next[j]）公共前后缀长度数组 next[i] = j以i为终点的后缀，和从1开始的前缀相等，且后缀的长度最长 p[1, j] = p[i - j + 1, i] 如何运用这一预处理 前面肯定是不能匹配继续走了，为了节省时间我们可以通过这个next[j]（为什么是j呢，因为在代码举例中j才是代码模版串的标识），总儿言之会得到一个长度，这就代表了上面i的前一部分next[j]长度和下面可以直接匹配，而这也刚好是之后的下标。 ![image-20220224230512716](/Users/mac/Library/Application Support/typora-user-images/image-20220224230512716.png) Tire 高效地存储和查找字符串集合的数据结构 ![image-20220226111317916](/Users/mac/Library/Application Support/typora-user-images/image-20220226111317916.png) 并查集(面试重点) 面试官喜欢的问题主要是代码比较短，思维性比较强 快速的处理这样的问题（适用场景）： 近乎O(1)地完成操作 将两个集合合并 a:1000 b:2000 将a的编号改为b（改b也行），起码需要1000次 询问两个元素是否在一个集合中 用一个数组来存储每个元素属于哪一个集合 belong[x] = a：x属于a这个集合 if(belong[x] == belong[y]) O(1) 判断x和y是不是在一个集合中 实现思路（递归）： 每一个集合用一颗树表示（不一定是二叉树） 树根的编号就是整个集合的编号 每个节点存储它的父节点，p[x]表示x的父节点 12345// 通过一个递归处理，让每一个节点的父节点，都变成了一个并查集中的祖宗节点int find(int x){ if(p[x] != x) p[x] = find(p[x]); return p[x];} 问题： 如何判断：if(p[x] == x)（除了根节点都不相等） 如何求x的集合编号：while(p[x] != x) x = p[x]; 如何合并两个集合：px是x的集合编号，py是y的集合编号，合并：p[x] = y 根据题目确定需要维护的信息 优化：路经压缩（遍历一遍之后都指向父节点） 补充：按秩合并 堆（完全二叉树） 如何手写一个堆？ 实现的功能： 插入一个数 heap[++size] = x; up(size) 求集合中的最小值 heap[1] 删除最小值 heap[1] = heap[szie]; size--; down(1) （以下STL无法直接实现） 删除任意一个元素 heap[k] = heap[size]; size--; //只会执行一个 down(k); up(k)； 修改任意一个元素 heap[k] = x; down(k); up(k); 小根堆：每一个点小于等于左右儿子 堆的存储： 使用一个一维数组来存 左儿子是2x，右儿子是2x+1 down（）操作、up（）操作 ![image-20220226145422095](/Users/mac/Library/Application Support/typora-user-images/image-20220226145422095.png) down(x) 数变大了，向下走，一直和最小的字节点交换位置（要保证最上面的点最小） up(x) 反之，比根节点小就交换 ![image-20220226154016930](/Users/mac/Library/Application Support/typora-user-images/image-20220226154016930.png) 分析 i为什么从n/2开始down？ 首先要明确要进行down操作时必须满足左儿子和右儿子已经是个堆。（否则down之后并不（一定）是一个堆） 开始创建堆的时候，元素是随机插入的，所以不能从根节点开始down，而是要找到满足下面三个性质的结点： 1.左右儿子满足堆的性质。 2.下标最大（因为要往上遍历） 3.不是叶结点（叶节点一定满足堆的性质） 那这个点为什么时n/2？看图。 时间复杂度分析： （如何建堆：最后一层可以不用管） ![image-20220226152258455](/Users/mac/Library/Application Support/typora-user-images/image-20220226152258455.png) 完整： ![image-20220227084850777](/Users/mac/Library/Application Support/typora-user-images/image-20220227084850777.png) 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N = 100010;int n, m;int h[N], si;// 映射关系 数的大小可能相同，但是下标都是唯一确定的// ph[j] = k：第j个插入的点下标是k// hp[k] = j：堆里面下标是k的点，是第j个插入的点int ph[N], hp[N];void heap_swap(int a, int b){ // a，b是指堆数组中的下标 swap(ph[hp[a]], ph[hp[b]]); // 交换 第k个数对下标的映射 swap(hp[a], hp[b]); // 交换 下标对第k个数的映射 swap(h[a], h[b]); // 交换 a，b的值}void down(int u){ // 用一个t来表示最小的节点 int t = u; // 左字节点存在，且左节点小于t节点的大小，t被重新复制 if(u * 2 &lt;= si &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; // 右字节点存在，且右节点小于t节点的大小，t被重新复制 if(u * 2 + 1 &lt;= si &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t){ heap_swap(u, t); down(t); }}void up(int u){ while(u/2 &amp;&amp; h[u/2] &gt; h[u]){ heap_swap(u/2, u); u/=2; }}int main(){ scanf(\"%d\", &amp;n); while(n--){ char op[10]; int k, x; scanf(\"%s\", op); if(!strcmp(op, \"I\")){ scanf(\"%d\", &amp;x); si++; // 漏掉了 m++; // 第m个插入的数 ph[m] = si; hp[si] = m; h[si] = x; up(si); } else if(!strcmp(op, \"PM\")) printf(\"%d\\n\", h[1]); else if(!strcmp(op, \"DM\")) { heap_swap(1, si); si--; down(1); } else if(!strcmp(op, \"D\")){ scanf(\"%d\", &amp;k); k = ph[k]; // 找到第k个数的下标 heap_swap(k, si); si--; //这里已经把那个数给删除了 down(k), up(k); // 这里的k是原来末尾的数，指的是下标k } else{ scanf(\"%d%d\", &amp;k, &amp;x); k = ph[k]; h[k] = x; down(k), up(k); } } return 0;} 哈希表 模拟散列表：维护的是一个集合（不重复） 散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f,使得每个关键字key对应一个存储位置f (key)。查找时，根据这个确定的对应关系找到给定值key的映射f (key),若查找集合中存在这个记录，则必定在f (key)的位置上。 ![image-20220227141341865](/Users/mac/Library/Application Support/typora-user-images/image-20220227141341865.png) 作用： 把一个庞大的空间（值域）映射到一个比较小的空间 拉链法 通过一个哈希函数h（x）：将-10的9次分到10的9次方的数映射到10的5次方 ![image-20220227152849728](/Users/mac/Library/Application Support/typora-user-images/image-20220227152849728.png) 添加：h(x) 查找：找一下h(x)，遍历 删除：打上布尔标记，删除的话就改一下标记，一般并不会删除 模一般取质数，冲突概率最小 int k = (x % N + N) % N; 这样对负数也可以进行处理（c++负数取模还是负数） 如果是（x + N）%N的话，由于x范围是10的9次分，n范围是10的五次分，所以可能还是一个负数。 哈希函数，将x映射到0-n-1 1234567891011121314151617// 求取质数int main(){ for(int i = 100000;; i++){ bool flag = true; for(int j = 2; j*j&lt;=i;j++){ if(i%j == 0){ flag = false; break; } } if(flag){ cout &lt;&lt; i &lt;&lt; endl; break; } } return 0;} 开放寻址法（用的比较多） 只开一维数组，没有开链表，2～3倍的题目数据范围（输入的数） 处理冲突：上厕所：坑位有人就去下一个坑位 添加：找k，向后一直找到空的坑位为止 查找：找k，从前往后找，一直找到空的坑位都没找到就是不存在 删除：查找，特殊标记 const int null = 0x3f3f3f3f 和 memset(h, 0x3f, sizeof h)之间的关系; 首先，必须要清楚memset函数到底是如何工作的先考虑一个问题，为什么memset初始化比循环更快？ 答案：memset更快，为什么？因为memset是直接对内存进行操作。memset是按字节（byte）进行复制的 void * memset(void *_Dst,int _Val,size_t _Size); 这是memset的函数声明 第一个参数为一个指针，即要进行初始化的首地址 第二个参数是初始化值，注意，并不是直接把这个值赋给一个数组单元（对int来说不是这样） 第三个参数是要初始化首地址后多少个字节 看到第二个参数和第三个参数，是不是又感觉了 h是int类型，其为个字节， 第二个参数0x3f八位为一个字节，所以0x3f * 4(从高到低复制4份) = 0x3f3f3f3f 这也说明了为什么在memset中不设置除了-1， 0以外常见的值 比如1, 字节表示为00000001，memset(h, 1, 4)则表示为0x01010101 为什么要取0x3f3f3f,为什么不直接定义无穷大INF = 0x7fffffff,即32个1来初始化呢？ 首先，0x3f3f3f的体验感很好，0x3f3f3f3f的十进制是1061109567，也就是109级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于109的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 比如0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit，int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。 但是INF不同，一旦加上某个值，很容易上溢，数值有可能转成负数，有兴趣的小伙伴可以去试一试。 0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的（3f = 11111111），它能够对数组清零是因为0的每个字节都是0，现在如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。 在算法竞赛中，我们常常需要用到设置一个常量用来代表“无穷大”。 比如对于int类型的数，有的人会采用INT_MAX，即0x7fffffff作为无穷大。但是以INT_MAX为无穷大常常面临一个问题，即加一个其他的数会溢出。 而这种情况在动态规划，或者其他一些递推的算法中常常出现，很有可能导致算法出问题。 所以在算法竞赛中，我们常采用0x3f3f3f3f来作为无穷大。0x3f3f3f3f主要有如下好处： 0x3f3f3f3f的十进制为1061109567，和INT_MAX一个数量级，即109数量级，而一般场合下的数据都是小于109的。 0x3f3f3f3f * 2 = 2122219134，无穷大相加依然不会溢出。 可以使用memset(array, 0x3f, sizeof(array))来为数组设初值为0x3f3f3f3f，因为这个数的每个字节都是0x3f。 字符串哈希（字符串前缀哈希法） 作用：快速判断 我们可以用前缀的哈希，用公式算出任意一个子串的哈希值 前缀的哈希值，前几位字母的哈希值 将字符串转换为P进制的数，对数取模，得到0～Q-1 注意： 不要映射成0 A和AA无法区分 Rp（人品）足够好、无冲突 经验值：P = 131 或 1331Q = 2^64，这种情况下99%都不会发生冲突 前面的哈希是处理冲突，这里是假定不会产生冲突 ![image-20220227214831926](/Users/mac/Library/Application Support/typora-user-images/image-20220227214831926.png) Q模2^64 使用unsigned long long存储h的值，会溢出相当于取模 ![image-20220227220752022](/Users/mac/Library/Application Support/typora-user-images/image-20220227220752022.png) ![字符串前缀哈希](/Users/mac/Library/Application Support/typora-user-images/字符串前缀哈希.jpeg) 前缀预处理 ![image-20220227221035004](/Users/mac/Library/Application Support/typora-user-images/image-20220227221035004.png) 实现思路： 如果两个区间的哈希值相同，则认为字符串相同 STL ![image-20220309225013089](/Users/mac/Library/Application Support/typora-user-images/image-20220309225013089.png) vector vector（变长数组），倍增的思想，支持比较运算（按字典序） 定义： vector a; 定义：一个vector数组a vector a(10); 定义：一个长度为10的vector数组a vector a(10,3); 定义：一个长度为10的vector数组a，并且所有元素都为3 常用函数： size(); 返回元素个数 时间复杂度O(1) empty(); 返回是否是空 clear(); 清空 队列没有 front(); 返回vector的第一个数 back(); 返回vector的最后一个数 push_back(); 向vector的最后插入一个数 pop_back(); 把vector的最后一个数删掉 begin(); vector的第0个数 end(); vector的最后一个的数的后面一个数 倍增的思想： 系统为某一程序分配空间是，所需时间，与空间大小无关，与申请次数有关。空间不够的时候，就数组的长度 * 2，再copy过来原来的元素。 遍历方法 假设有个vector a; 第一种： ​ for(int i = 0;i &lt; a.size();i ++) cout&lt;&lt;a[i]&lt;&lt;\" \"; 第二种： ​ for(vector ::iterator i = a.begin();i != a.end();i ++) cout&lt;&lt;*i&lt;&lt;\" \"; vector ::iterator可以写为auto 第三种： ​ for(auto x : a) cout&lt;&lt;x&lt;&lt;\" \"; 123456789101112vector&lt;int&gt; a;for(int i = 0; i &lt; 10; i ++) a.push_back(i);for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; ' ';cout &lt;&lt; endl;// 迭代器遍历for(vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt;' ';cout &lt;&lt; endl;for(auto x : a) cout &lt;&lt; x &lt;&lt; ' '; 支持比较运算（按照字典序） 1234567int main(){ vector&lt;int&gt; a(4,3), b(3, 4); if(a &lt; b) puts(\"a &lt; b\"); return 0;} pair&lt;int, int&gt; pair，存储一个二元组 支持比较运算，以first为第一关键字，以second为第二关键字（按字典序） 定义： pair &lt;类型,类型&gt; 变量名; 两个类型可以不同 初始化方式：假设有个pair &lt;int,string&gt; p; 第一种：p = make_pair(10,“abc”); 第二种： p = {10,“abc”); 常用函数： first(); 第一个元素 second(); 第二个元素 使用场景： 某个东西两种不同属性，用pair存，需要排序，把需要用来排序的放在first里面 pair&lt;int, pair&lt;int, int&gt;&gt; p; string（字符串） ​ 常用函数：： ​ substr(); 返回每一个子串 ​ c_str(); 返回这个string对应的字符数组的头指针 ​ size(); 返回字母个数 ​ length(); 返回字母个数 ​ empty(); 返回字符串是否为空 ​ clear(); 把字符串清空 queue（队列） ​ 定义：： ​ queue &lt;类型&gt; 变量名; ​ 常用函数：： ​ size(); 这个队列的长度 ​ empty(); 返回这个队列是否为空 ​ push(); 往队尾插入一个元素 ​ front(); 返回队头元素 ​ back(); 返回队尾元素 ​ pop(); 把队头弹出 ​ 注意：队列没有clear函数！！！ ​ 清空： ​ 变量名 = queue (); priority_queue（优先队列，堆） ​ 注意：默认是大根堆！！！ ​ 定义：： ​ 大根堆：priority_queue &lt;类型&gt; 变量名; ​ 小根堆：priority_queue &lt;类型,vecotr &lt;类型&gt;,greater &lt;类型&gt;&gt; 变量名 ​ 常用函数： ​ size(); 这个堆的长度 ​ empty(); 返回这个堆是否为空 ​ push();往堆里插入一个元素 ​ top(); 返回堆顶元素 ​ pop(); 弹出堆顶元素 ​ 注意：堆没有clear函数！！！ stack（栈） 常用函数： size(); 这个栈的长度 empty(); 返回这个栈是否为空 push(); 向栈顶插入一个元素 top(); 返回栈顶元素 pop(); 弹出栈顶元素 deque（双端队列） 常用函数： size(); 这个双端队列的长度 empty(); 返回这个双端队列是否为空 clear(); 清空这个双端队列 front(); 返回第一个元素 back(); 返回最后一个元素 push_back(); 向最后插入一个元素 pop_back(); 弹出最后一个元素 push_front(); 向队首插入一个元素 pop_front(); 弹出第一个元素 begin(); 双端队列的第0个数 end(); 双端队列的最后一个的数的后面一个数 set，map，multiset，multimap 基于平衡二叉树（红黑树），动态维护有序序列 set/multiset 注意：set不允许元素重复，如果有重复就会被忽略，但multiset允许！！！ 常用函数： size(); 返回元素个数 empty(); 返回set是否是空的 clear(); 清空 begin(); 第0个数，支持或–，返回前驱和后继 end(); 最后一个的数的后面一个数，支持或–，返回前驱和后继 insert(); 插入一个数 find(); 查找一个数 count(); 返回某一个数的个数 erase(); （1）输入是一个数x，删除所有x O(k + log n) （2）输入一个迭代器，删除这个迭代器 lower_bound(x); 返回大于等于x的最小的数的迭代器 upper_bound(x); 返回大于x的最小的数的迭代器 map/multimap 常用函数： insert(); 插入一个数，插入的数是一个pair erase(); （1）输入是pair （2）输入一个迭代器，删除这个迭代器 find(); 查找一个数 lower_bound(x); 返回大于等于x的最小的数的迭代器 upper_bound(x); 返回大于x的最小的数的迭代器 unordered_set，unordered_map，unordered_muliset,unordered_multimap 基于哈希表 和上面类似，增删改查的时间复杂度是O(1) 不支持lower_bound()和upper_bound() bitset 压位 定义： bitset &lt;个数&gt; 变量名; 支持： ~，&amp;，|，^ &gt;&gt;，&lt;&lt; ==，!= [] 常用函数： count(); 返回某一个数的个数 any(); 判断是否至少有一个1 none(); 判断是否全为0 set(); 把所有位置赋值为1 set(k,v); 将第k位变成v reset(); 把所有位变成0 flip(); 把所有位取反，等价于~ flip(k); 把第k位取反 第三讲 搜索与图论 难点在于建模，如何把实际问题转换为模型 ![image-20220228210745865](/Users/mac/Library/Application Support/typora-user-images/image-20220228210745865.png) BFS：最短路径 DFS：奇怪/对空间要求比较高 深度优先搜索 DFS 重要概念： 回溯 剪枝 顺序，而不是思路 DFS难以思考的话，从搜索树的角度考虑，每一个DFS都对应一颗搜索树 重点在于剪枝和回溯： 剪枝：if语句进行判断（根据题目条件），例：如果已经出现了这个数（）就不用向下走 回溯：恢复现场，例如如果向下走，要进行标记（走过了），回溯就需要把这些标记恢复原状 实现过程： 当位数符合要求（填满）输出 位数不足需要继续填充的时候，递归 ![image-20220228210411343](/Users/mac/Library/Application Support/typora-user-images/image-20220228210411343.png) ![image-20220228215458970](/Users/mac/Library/Application Support/typora-user-images/image-20220228215458970.png) 八皇后问题(都是DFS) 顺序 每一行进行枚举 每一个格子挨个枚举 广度优先搜索 BFS 一般用于实现最短路问题，边权都是1的时候一般这么做（不是所有最短路都能用BFS，一般用专门的最短路算法（时间复杂度高））DP时间复杂度低 dp可以看作是一种特殊的最短路问题 模版： ![image-20220301171624410](/Users/mac/Library/Application Support/typora-user-images/image-20220301171624410.png) ![image-20220228210456510](/Users/mac/Library/Application Support/typora-user-images/image-20220228210456510.png) 树与图的深度广度优先遍历 树和图的存储 1234567891011121314151617#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100010, M = N*2;int h[N], e[M], ne[M], idx;void add(int a, int b){ e[idx] = b, ne[idx] = h[a], ha[a] = idx++;}int main(){ memset(h, -1, sizeof h);} 树是一种特殊的图：无环连通图 有向图、无向图：无向图是一种特殊的有向图 邻接矩阵：二维数组 邻接表：单链表。我们通过对每一个节点都构造出一个链表，就形成了邻接表 ![image-20220301212634582](/Users/mac/Library/Application Support/typora-user-images/image-20220301212634582.png) 树和图的遍历（有向图的遍历） 深度优先遍历（DFS） 123456789101112131415161718192021222324252627282930#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n, m;const int N = 100010, M = N*2;bool st[N];int h[N], e[M], ne[M], idx;void add(int a, int b){ e[idx] = b, ne[idx] = h[a], ha[a] = idx++;}void dfs(int u){ st[u] = true; // 已经被搜过了 for(int i = h[u]; i!= -1; i = ne[i]){ int j = e[i]; if(!st[j]) dfs(j); }}int main(){ memset(h, -1, sizeof h); dfs(1); reutrn 0;} 树的重心 重点： 我们可以使用DFS得到：以u为根的子树点的数量 可以使用n - sum得到除了子树外的连通块的大小（这也就意味每一个点只需要遍历一遍） M = N * N，有N个点，add我们是要操作两次的 实现思路： 只要求出，每一个点，删除该点之后，其余所有连通块的点数的最大值，这之中的最小值就是答案 如何求出把点删除之后，剩余连通块的点数的最大值 我们可以通过树的深度遍历，求出每个点子树的点的数量 子树的点数可以返回回来 上面点点数可以通过 n - Size[n] 在递归的过程中，处理每一个点的时候，都能算出在把它删除了之后，其余所有部分的连通块的大小，就能找到一个最大值。 ![image-20220301223156660](/Users/mac/Library/Application Support/typora-user-images/image-20220301223156660.png) 宽度优先遍历（BFS） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1e2 + 7;int g[N][N], d[N][N];int n, m;int bfs() { int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}; queue &lt;PII&gt; q; for (auto &amp;v : d) for (auto &amp;x : v) { x = - 1; } d[0][0] = 0; q.push({0, 0}); while (!q.empty()) { auto t = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) { int x = t.first + dx[i], y = t.second + dy[i]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1) { d[x][y] = d[t.first][t.second] + 1; q.push({x, y}); } } } return d[n - 1][m - 1];}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { cin &gt;&gt; g[i][j]; } } cout &lt;&lt; bfs() &lt;&lt; endl; return 0;} 图中点的层次遍历 所有边点长度都为1，说明可以使用BFS ![image-20220302094855148](/Users/mac/Library/Application Support/typora-user-images/image-20220302094855148.png) 拓扑排序（图的宽搜的应用） 针对有向图 所有的边都是从前指向后 有环一定没有拓扑序列 有向无环图也叫拓扑图 度数：入度（有多少条边指向自己） 出度（有多少边出去） 有向无环图至少有一个入度为0点点 出队的顺序恰好就是拓扑序列 ![image-20220302101020476](/Users/mac/Library/Application Support/typora-user-images/image-20220302101020476.png) 实现思路： 入度为0，即为起点，排在当前最前的位置 最开始的入度为0度点怎么找呢？ 遍历一遍d[N] 环上没有一个点能满足入度为0点条件 ![image-20220302102727282](/Users/mac/Library/Application Support/typora-user-images/image-20220302102727282.png) 最短路问题 难点在建图，而不是正确性，重点在于算法的实现思路以及代码的模版 ![image-20220302132449948](/Users/mac/Library/Application Support/typora-user-images/image-20220302132449948.png) 分类： 单源最短路问题：从一个点到多个点到最短路径 所有边权都是正数 朴素Dijkstra算法 O(n^2) 适合：稠密图 堆优化版的Dijkstra算法 O(mlogn) 存在负权边 Bellman-Ford O(nm) SPFA 一般是O(m) 最坏O(nm) 多源汇最短路问题：起点和终点都是不确定的 Floyd算法 O(n^3) 1. Dijkstra 边数很多，稠密图，使用邻接矩阵 初始化距离dis[i] = 0, dis[i] = +∞，s为当前已确定的最短距离的点的集合（从一个固定点） 为什么这里初始化dis数组的时候是用0x3f，之前都是用-1？ 因为之前只需要确定一次路径（-1和0x3f都行），而这里需要连续的迭代去得到最短的路径，直接初始化（无穷大）可以减少判断条件 一个迭代的过程：每次确定一个点到起点的最短路，确定当前还没确定的点中距离最小的点（一定是最短路，基于贪心） for(int i = 1; i &lt;= n; i++) 找到不在s中的距离起点最近的点 for 1-n 将t放到s中去 用t更新其他所有点的距离 for 1-n ![image-20220302144658826](/Users/mac/Library/Application Support/typora-user-images/image-20220302144658826.png) ![image-20220302133314333](/Users/mac/Library/Application Support/typora-user-images/image-20220302133314333.png) 朴素版Dijkstra 适合稠密图（使用邻接矩阵进行存储） 时间复杂度分析 寻找路径最短的点：O(n^2) 加入集合S：O(n) 更新距离：O(m) 所以总的时间复杂度为O(n^2) 思路： 我认为还需要注意的一点是，这里没有把1号放入s集合（确定了最短路径的集合）中 首先可以简化操作，不需要多写一轮用1（起点）来更新其他点到起点的距离 其次如果起点到终点的距离就是最短的距离的话，又回需要更加复杂的判断条件使之不进行后续的更新 集合S为已经确定最短路径的点集。 初始化距离 一号结点的距离为零，其他结点的距离设为无穷大（看具体的题）。 循环n次，每一次将集合S之外距离最短X的点加入到S中去（这里的距离最短指的是距离1号点最近。点X的路径一定最短，基于贪心，严格证明待看）。然后用点X更新X邻接点的距离。 堆优化版Dijkstra 适合稀疏图（使用邻接表进行存储，多加一个权重） 时间复杂度分析 寻找路径最短的点：O(n) 加入集合S：O(n) 更新距离：O(mlogn) 思路： 堆优化版的dijkstra是对朴素版dijkstra进行了优化，在朴素版dijkstra中时间复杂度最高的寻找距离最短的点O(n^2)可以使用最小堆优化。 一号点的距离初始化为零，其他点初始化成无穷大。 将一号点放入堆中。 不断循环，直到堆空。每一次循环中执行的操作为： 弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点的最短路径已经确定）。 用该点更新临界点的距离，若更新成功就加入到堆中。 重点： STL库中的堆不可以实现对容易一个点就行修改，只能添加（产生冗余） heap({distance, ver}) 这样就会是按照最短距离排序 由于只能添加，所以我们通过st进行判断是否已经确定了最短路径（就不再遍历这个点了） 如果更新会怎么样？ 由于每次都用最短的距离更新，所以重复的点并不会得到更好的结果，反而加大了工作量 2. bellman-ford 处理有负权边的情况 如果有负权回路，则不一定存在最短距离 无最短距离：通向n点的路径上有负环![image-20220303131204859](/Users/mac/Library/Application Support/typora-user-images/image-20220303131204859.png) 有最短距离：虽然有负环嘛，但是到不了n![image-20220303132314138](/Users/mac/Library/Application Support/typora-user-images/image-20220303132314138.png) 可以求负环，但是时间复杂度比较高 一般情况下差与SPFA算法 但是在有边数限制的最短路里面，只能用到这个算法 迭代k次：从1号点，经过不超过k条边，走到每个点点最短距离 n次迭代之后，又更新了边的话，就说明存在一条边数为n的最短路径（没有第n+1个点），就说明存在负环。每次有更新的话最短路径的边数都会多一 ![image-20220303130928885](/Users/mac/Library/Application Support/typora-user-images/image-20220303130928885.png) 使用backup来防止串联 ![image-20220303134420226](/Users/mac/Library/Application Support/typora-user-images/image-20220303134420226.png) 注意： 为什么是dist[n]&gt;0x3f3f3f3f/2， 而不是dist[n]&gt;0x3f3f3f3f 5号节点距离起点的距离是无穷大，利用5号节点更新n号节点距离起点的距离，将得到109−2 , 虽然小于109 , 但并不存在最短路，(在边数限制在k条的条件下)。 3. spfa 对Bellman-Ford优化（宽度优先搜索） 没有负环的最短路就能使用 实现思路： 只有a变小了，b才可能变小 ![image-20220303164342054](/Users/mac/Library/Application Support/typora-user-images/image-20220303164342054.png) 更新过谁，就拿他去更新别人 ![image-20220303162737129](/Users/mac/Library/Application Support/typora-user-images/image-20220303162737129.png) 4. Floyd 邻接矩阵存储 基于动态规划 ![image-20220303191101799](/Users/mac/Library/Application Support/typora-user-images/image-20220303191101799.png) 最小生成树（无向图 ![image-20220304103627091](/Users/mac/Library/Application Support/typora-user-images/image-20220304103627091.png) Prim 1. 朴素版Prim（稠密图） 区别：Dijkstra是到起点的距离最小值![image-20220304104824524](/Users/mac/Library/Application Support/typora-user-images/image-20220304104824524.png) 2. 堆优化Prim（稀疏图） 百分百不会用。。。不讲了 Kruskal ![image-20220306143103630](/Users/mac/Library/Application Support/typora-user-images/image-20220306143103630.png) 二分图 ![image-20220304103912860](/Users/mac/Library/Application Support/typora-user-images/image-20220304103912860.png) 染色体判定二分图（DFS） 染色法性质： 将所有点分成两个集合，使得所有边只出现在集合之间，就是二分图 二分图：一定不含有奇数环，可能包含长度为偶数的环， 不一定是连通图 边的两边颜色不一样 DFS版本代码思路： 染色可以使用1和2区分不同颜色，用0表示未染色 遍历所有点，每次将未染色的点进行dfs, 默认染成1或者2 由于某个点染色成功不代表整个图就是二分图**,因此只有某个点染色失败才能立刻break/return** 染色失败相当于存在相邻的2个点染了相同的颜色 BFS版本代码思路 --需要手写再次实现 颜色 1 和 2 表示不同颜色, 0 表示 未染色 定义queue是存PII，表示 &lt;点编号, 颜色&gt;, 同理，遍历所有点, 将未染色的点都进行bfs 队列初始化将第i个点入队, 默认颜色可以是1或2 while (队列不空) 每次获取队头t, 并遍历队头t的所有邻边 若邻边的点未染色则染上与队头t相反的颜色，并添加到队列（后续继续遍历） 若邻边的点已经染色且与队头t的颜色相同, 则返回false 匈牙利算法 第五讲 动态规划 背包问题 线性DP 区间DP 计数类DP 数位统计DP 状态压缩DP 树形DP 记忆化搜索 第六讲 贪心 区间问题一般先排序，端点从小到大排序 贪心的思想是局部最优解，只在乎眼前最好的方法 ![image-20220310163414689](/Users/mac/Library/Application Support/typora-user-images/image-20220310163414689.png) 需要证明Ans = cnt：Ans为目标值（可行解中的最优解，本题为最小值） cnt是我们当前这种选取方案的解。 Ans &lt;= cnt：cnt 是一种可行方案， ans是可行方案的最优解，也就是最小值。 Ans &gt;= cnt：cnt可行方案是一个区间集合，区间从小到大排序，两两之间不相交。所以覆盖每一个区间至少需要cnt个点。 最大不相交区间数量 证明：Ans = cnt Ans &gt;= cnt：按照套路选出的区间，相互之间没有交集，是一种可行方案，答案是可行方案的最大值。 Ans &lt;= cnt：假设Ans大于cnt（有Ans个区间没有交集），即可以选出比cnt更多的（Ans个点才能覆盖所有区间）不相交区间，与实际不符（只需要cnt个点就可以覆盖掉所有不相交的区间） 区间分组 ![ ](/Users/mac/Library/Application Support/typora-user-images/image-20220310205231504.png) 证明：Ans = cnt，Ans是答案，cnt表示我们这一方法得到的答案 Ans &lt;= cnt：cnt是一种合法方案 Ans &gt;= cnt：选取一个特殊的时刻，整个cnt个区间都有公共点，所以每一个区间都不会在一个组里面。Ans &gt;= cnt。 ![image-20220310210315390](/Users/mac/Library/Application Support/typora-user-images/image-20220310210315390.png) 如何判断是否存在一个组：（最小的）Max_r &lt; L[i] 区间覆盖 ans可以逐步替换成最优解 ![image-20220311165826346](/Users/mac/Library/Application Support/typora-user-images/image-20220311165826346.png) 证明：Ans = cnt Ans &lt;= cnt：cnt是一种可行方案，Ans是最小值 Ans &gt;= cnt：反证法。假设存在ans &lt; cnt，那么cnt里面有一点区间是不满足我们选择规则的，cnt会可以换成ans中的部分区间，最后会ans = cnt，产生矛盾，所以得证。","categories":[{"name":"算法","slug":"算法","permalink":"https://zwh1y.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://zwh1y.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"模版","slug":"模版","permalink":"https://zwh1y.github.io/tags/%E6%A8%A1%E7%89%88/"}]}],"categories":[{"name":"test","slug":"test","permalink":"https://zwh1y.github.io/categories/test/"},{"name":"论文","slug":"论文","permalink":"https://zwh1y.github.io/categories/%E8%AE%BA%E6%96%87/"},{"name":"算法","slug":"算法","permalink":"https://zwh1y.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"test","slug":"test","permalink":"https://zwh1y.github.io/tags/test/"},{"name":"slam","slug":"slam","permalink":"https://zwh1y.github.io/tags/slam/"},{"name":"目标检测","slug":"目标检测","permalink":"https://zwh1y.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"目标追踪","slug":"目标追踪","permalink":"https://zwh1y.github.io/tags/%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA/"},{"name":"基础","slug":"基础","permalink":"https://zwh1y.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"模版","slug":"模版","permalink":"https://zwh1y.github.io/tags/%E6%A8%A1%E7%89%88/"}]}