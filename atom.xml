<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kun&#39;s blog</title>
  
  
  <link href="https://zwh1y.github.io/atom.xml" rel="self"/>
  
  <link href="https://zwh1y.github.io/"/>
  <updated>2022-05-08T06:44:22.173Z</updated>
  <id>https://zwh1y.github.io/</id>
  
  <author>
    <name>Kun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AcWing算法基础课笔记</title>
    <link href="https://zwh1y.github.io/2022/05/08/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://zwh1y.github.io/2022/05/08/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%AC%94%E8%AE%B0/</id>
    <published>2022-05-08T06:40:53.000Z</published>
    <updated>2022-05-08T06:44:22.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一讲-基础算法"><a href="#第一讲-基础算法" class="headerlink" title="第一讲 基础算法"></a>第一讲 基础算法</h1><p>主要思想：代码为什么是对的、为什么这样写，需要有一个深刻的理解。</p><p>课后：</p><ul><li>背过代码（快速的默写出模版，调试之后能过）</li><li>课后习题 （）每个题目写个3-5遍</li></ul><h2 id="1-快速排序（已过）"><a href="#1-快速排序（已过）" class="headerlink" title="1. 快速排序（已过）"></a>1. 快速排序（已过）</h2><p>思想：<strong>基于分治</strong></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>![image-20220210144232572](/Users/mac/Library/Application Support/typora-user-images/image-20220210144232572.png)</p><ul><li><p>思想：</p><ul><li>确定分界点：q[l] q[r] q[l + r &gt;&gt; 1]</li><li><strong>调整区间</strong>：x左边的数都小于等于x， x右边的数都大于等于x</li><li>递归处理左右两段</li></ul></li><li><p><strong>复习出现的错误：</strong></p><ol><li><p>do while循环不熟练，do后面的i++也需要加上；</p></li><li><p>递归处理的时候越界了，写的分界点是j-1和j？？？（暂时不知道为什么）经过测试，使用i-1和i分界也会出错，使用 + 1就不会。</p></li><li><p><code>x = l + r &gt;&gt; 1</code>出错，如果我们不使用<code>x = q[l + r &gt;&gt; 1]</code>。这里如果每次记住的是下标，那么每次都是那个固定的下标，然而下标的固定并不能保证下标里面存放的值是固定的，尤其是在进行swap交换的过程中，可能会出现对应的值发生了变化，如果此时坚持使用q[下标] 当下标对应的位置改变的时候q[下标]第k个数也会改变，但是我们选点的时候是根据一个固定的值，左边全部小于等于x右边全部大于等于x。违背了这个初衷就会WA</p><blockquote><p>我们每次while循环需要用同一个值来进行比较，如果保存下标的话，在交换后可能导致同一个while循环中比较的数改变，从而造成错误。</p></blockquote></li></ol></li></ul><hr><p>![image-20220309091843756](/Users/mac/Library/Application Support/typora-user-images/image-20220309091843756.png)</p><ul><li>Sl和Sr表示的是个数</li></ul><p><strong>重点思想：</strong></p><ul><li>多了一个k，排序之后，通过左边的数和右边数的个数辅助判断</li></ul><h2 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2. 归并排序"></a>2. 归并排序</h2><p><strong>思想：基于分治</strong></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>![image-20220210151729930](/Users/mac/Library/Application Support/typora-user-images/image-20220210151729930.png)</p><ul><li><p>思想：</p><ul><li>确定分界点：mid  = (l + r) &gt;&gt; 2 <em>和快速排序的区别是快速排序是数组中的值，而这里用的是下标</em></li><li>递归排序 left right</li><li><strong>归并</strong> 合并两个有序的数组</li></ul></li><li><p>代码实现：</p></li></ul><ol><li>递归终止情况</li><li>分成子问题，递归处理子问题</li><li>合并子问题</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//递归的终止情况</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：分成子问题</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：递归处理子问题</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid ), <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：合并子问题</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>, tmp[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>边界分析：</strong></p><ul><li><p><strong>为什么不用 mid - 1 作为分隔线呢？</strong></p><p>即 merge_sort(q, l, mid - 1 ), merge_sort(q, mid, r)</p><p>因为 mid = l + r &gt;&gt; 1 是向下取整，mid 有可能取到 l (数组只有两个数时)，造成无限划分</p></li><li><p><strong>解决办法:</strong> mid 向上取整就可以了, 即 mid = l + r + 1 &gt;&gt; 1,如下所示:</p></li></ul></li></ul><h3 id="逆序对的数量"><a href="#逆序对的数量" class="headerlink" title="逆序对的数量"></a>逆序对的数量</h3><hr><h2 id="3-二分"><a href="#3-二分" class="headerlink" title="3. 二分"></a>3. 二分</h2><p>二分的本质是二段性</p><p>有单调性一定可以二分，没有单调性也有可能可以二分</p><p>重点：<br>    1. check需要自己定义去找一个最合适的</p><h3 id="数的范围"><a href="#数的范围" class="headerlink" title="数的范围"></a>数的范围</h3><p>![image-20220327204537182](/Users/mac/Library/Application Support/typora-user-images/image-20220327204537182.png)</p><p>![image-20220327224242273](/Users/mac/Library/Application Support/typora-user-images/image-20220327224242273.png)</p><p>![image-20220210160017818](/Users/mac/Library/Application Support/typora-user-images/image-20220210160017818.png)</p><p>图示如下：</p><p>![image-20220315221453548](/Users/mac/Library/Application Support/typora-user-images/image-20220315221453548.png)</p><p>![image-20220315210734201](/Users/mac/Library/Application Support/typora-user-images/image-20220315210734201.png)</p><ul><li><p>mid = l + r  + 1&gt;&gt; 1     找小于等于x的数，判断 mid &lt;= x是否成立</p><p>if(check(mid))  true  [mid, r]      更新：l = mid</p><p>​                          false [l, mid - 1] 更新：r = mid - 1</p></li></ul><p>![image-20220315211523555](/Users/mac/Library/Application Support/typora-user-images/image-20220315211523555.png)</p><ul><li><p>mid =  l + r &gt;&gt; 1         找大于等于x的数，判断mid &gt;= x是否成立</p><p>if(check(mid)) true [l, mid]        更新：r = mid</p><p>​                     false[mid + 1, r] 更新：l = mid + 1</p></li><li><p>是否加1:看更新区间，如果是<strong>l = mid</strong>就需要补一个 + 1，如果是<strong>r=mid</strong>就不需要补上+ 1。</p></li><li><p>如何理解mid +1还是-1:</p><ul><li>判断q[mid] &gt;= x，不满足的话，mid就不会在区间内,更新后的区间要靠近r，所以要让 l = mid + 1</li><li>判断q[mid] &lt;= x，不满足的话，mid就不会在区间内,更新后的区间要靠近l，所以要让 r = mid - 1</li></ul></li></ul><h3 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h3><p>浮点数二分，没有精度问题，好写</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>){ <span class="comment">// 精度提高，比输出多2就没问题</span></span><br><span class="line">        <span class="type">double</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>循环写法(区间变为原来的100分之一)</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++){</span><br><span class="line">        <span class="type">double</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-高精度"><a href="#4-高精度" class="headerlink" title="4. 高精度"></a>4. 高精度</h2><p>c++需要 </p><p>java中有大整数类 python默认是无限大</p><p>A &lt;= 10与len(A) &lt; 10 0-9999999999</p><p>都是使用大数组进行存储</p><p>处理中使用到了A[i] - ‘0’（自动转换为ASCII码的值相减）相减得到的就是数值</p><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><ul><li>大数组存储</li><li>模拟人工加法的过程 每次计算的时候使用到了三个数Ai Bi 以及 t（进位）</li><li>使用数组表示A B C（使用vector数组就可以不需要额外使用变量来获取长度）</li><li>使用一个t来表示进位</li></ul><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>![image-20220212143839690](/Users/mac/Library/Application Support/typora-user-images/image-20220212143839690.png)</p><ul><li>需要保证 A &gt;= B,  如果A &lt;B，则计算B-A加上一个负号</li><li>设计到负数就使用绝对值计算出再进行符号判断</li><li>t表示是当前位数的数值，以及用来判断是否借位（取值为1或者0）</li><li>注意：去掉前导0（除非数值为0）</li></ul><h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><ul><li>与高精度加法类似，利用到t来计算进位</li></ul><h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><hr><h2 id="5-前缀和与差分（其实是一对逆运算）"><a href="#5-前缀和与差分（其实是一对逆运算）" class="headerlink" title="5. 前缀和与差分（其实是一对逆运算）"></a>5. 前缀和与差分（其实是一对逆运算）</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>注意：</p><ol><li>就是算出前n项和，比较简单</li><li>题目一遍问的是第几个数到第几个数，所以从1开始会比较好理解，不容易出错。</li></ol><p>![image-20220212194305121](/Users/mac/Library/Application Support/typora-user-images/image-20220212194305121.png)</p><h3 id="子矩阵的和"><a href="#子矩阵的和" class="headerlink" title="子矩阵的和"></a>子矩阵的和</h3><p>注意：</p><ol><li>输出的计算：<code>s[x2][y2] - s[x2][y1 - 1] -s[x1 - 1][y2] + s[x1 - 1][y1 - 1]</code></li></ol><p>![image-20220214104150816](/Users/mac/Library/Application Support/typora-user-images/image-20220214104150816.png)</p><h3 id="差分（不需要考虑如何构造，只要考虑如何）"><a href="#差分（不需要考虑如何构造，只要考虑如何）" class="headerlink" title="差分（不需要考虑如何构造，只要考虑如何）"></a>差分（不需要考虑如何构造，只要考虑如何）</h3><p>差分数组是一个数组 存放的是<strong>相邻数据</strong>之间的<strong>差值</strong></p><ul><li><p>假象一个b数组，b的前缀和是a，b被称为a的差分</p></li><li><p>用处：O(1)的时间解决原来O(n)的问题</p></li><li><p>**假定a1 - an都是0，差分数组也就是都是0，假定插入了n次插入操作，每次让原数组[n, n]的区间插入a[n]**：插入操作操作就可以直接使用到公式（在原数组a的一段区间中插入值）：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span>{</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>![image-20220214113403124](/Users/mac/Library/Application Support/typora-user-images/image-20220214113403124.png)</p><p>![image-20220214113811487](/Users/mac/Library/Application Support/typora-user-images/image-20220214113811487.png)</p><h3 id="差分矩阵（二维差分）"><a href="#差分矩阵（二维差分）" class="headerlink" title="差分矩阵（二维差分）"></a>差分矩阵（二维差分）</h3><ul><li><p>令aij等于0，显然bij等于零，再根据aij实际值，插入一遍就好了</p></li><li><p>公式：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span>{</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] +=c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>![image-20220214155746725](/Users/mac/Library/Application Support/typora-user-images/image-20220214155746725.png)</p><hr><h2 id="6-双指针算法"><a href="#6-双指针算法" class="headerlink" title="6. 双指针算法"></a>6. 双指针算法</h2><p><strong>核心思想：</strong>将一个复杂度更高的计算，优化</p><p>![image-20220318204523962](/Users/mac/Library/Application Support/typora-user-images/image-20220318204523962.png)</p><ul><li><p>两大类：</p><ul><li>归并排序</li><li>快速排序</li></ul></li><li><p>j表示j往左，最左能到什么地方</p></li><li><p>先写下面的模版，再如何去做</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;n; i++){</span><br><span class="line"><span class="keyword">while</span>(j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j++;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 每道题的具体逻辑</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>核心思想：</p><ul><li>通过暴力先写暴力做法</li><li>在枚举的时候看，i和j的单调关系</li><li>利用单调关系把枚举数量从n^2变成n</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt; n; j++)</span><br><span class="line">      <span class="built_in">O</span>(n^<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 将上面的朴素算法优化到O(n)</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>简单的例题：将每个单词分别输出且各占一行。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gets</span>(str);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++){</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; str[j] != <span class="string">' '</span>) j++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这道题的具体逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; j; k++) cout &lt;&lt; str[k];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        i = j;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h3><p><strong>核心思路：</strong></p><ol><li>遍历数组a中的每一个元素a[i], 对于每一个i，找到j使得双指针[j, i]<strong>维护的是以 a[i]结尾 的最长连续不重复子序列</strong>，长度为i - j + 1, 将这一长度与r的较大者更新给r。</li><li>对于每一个i，如何确定j的位置：由于[j, i - 1]是前一步得到的最长连续不重复子序列，所以如果[j, i]中有重复元</li><li>素，一定是a[i]，因此右移j直到a[i]不重复为止（由于[j, i - 1]已经是前一步的最优解，此时j只可能右移以剔除重复元素a[i]，不可能左移增加元素，因此，j具有“单调性”、本题可用双指针降低复杂度）。</li><li>用数组s记录子序列a[j ~ i]中各元素出现次数，遍历过程中对于每一个i有四步操作：cin元素a[i] -&gt; 将a[i]出现次数s[a[i]]加1 -&gt; 若a[i]重复则右移j（s[a[j]]要减1） -&gt; 确定j及更新当前长度i - j + 1给r。</li></ol><p><strong>注意细节：</strong></p><ol><li>当a[i]重复时，先把a[j]次数减1，再右移j。</li></ol><p>![image-20220216145058032](/Users/mac/Library/Application Support/typora-user-images/image-20220216145058032.png)</p><ul><li><p>暴力：遍历起点和终点(i在右边，j在左边)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 朴素做法： O(n^2)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++){</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(i, j)){</span><br><span class="line">      res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>双指针算法：</p><ul><li>找到单调性等<strong>新的性质</strong>，简化时间复杂度</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>， j = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">  <span class="keyword">while</span>(j &lt;= i &amp;&amp; <span class="built_in">check</span>(j, i)) j++;</span><br><span class="line">  res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="数组元素的目标和"><a href="#数组元素的目标和" class="headerlink" title="数组元素的目标和"></a>数组元素的目标和</h3><h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h3><hr><h2 id="7-位运算"><a href="#7-位运算" class="headerlink" title="7. 位运算"></a>7. 位运算</h2><ul><li><p>n的二进制表示中第k位是几（个位是第0位）</p><ol><li>先把第k位移到最后一位 n &gt;&gt; k</li><li>看各位是几 x&amp;1</li><li>结合1、2之后，常用操作：n &gt;&gt; k &amp; 1</li></ol></li><li><p>lowbit(x)：返回x的最后一位1</p><p>![image-20220216162301007](/Users/mac/Library/Application Support/typora-user-images/image-20220216162301007.png)</p><p>x = 1010        lowbit(x) = 10(2)</p><p>x = 101000   lowbit(x) = 1000(4)</p><ol><li>实现原理：x&amp;-x </li><li>-x = <del>x + 1所以x&amp;-x = x&amp;(</del>x+1)</li></ol></li></ul><h3 id="二进制中1的个数-上述应用"><a href="#二进制中1的个数-上述应用" class="headerlink" title="二进制中1的个数(上述应用)"></a>二进制中1的个数(上述应用)</h3><p>![image-20220216162952102](/Users/mac/Library/Application Support/typora-user-images/image-20220216162952102.png)</p><hr><h2 id="8-离散化（整数有序）"><a href="#8-离散化（整数有序）" class="headerlink" title="8. 离散化（整数有序）"></a>8. 离散化（整数有序）</h2><ul><li>值域很大，但是内容稀疏</li><li>将下标离散化</li></ul><p>![image-20220227143216831](/Users/mac/Library/Application Support/typora-user-images/image-20220227143216831.png)</p><h3 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h3><blockquote><p>将下标离散化之后，离散化之后的下标插入对应的值，同时离散化的下标包括查找的区间，形成一个新的数组进行处理。</p></blockquote><p>![区间和](/Users/mac/Library/Application Support/typora-user-images/区间和.jpg)</p><p>![image-20220216165051104](/Users/mac/Library/Application Support/typora-user-images/image-20220216165051104.png)</p><ul><li><p>将<strong>下标</strong>拿过来排序，映射到从1开始的自然数，利用前缀和计算</p></li><li><p>给x加c 找x离散化之后的数是多少</p></li><li><p>L,R 也会放到离散化的容器中，这样可以方便找到需要求的值</p></li><li><p>unique实现：</p><ol><li>它是第一个数</li><li>它和前一个数不一样，即：a[i] != a[i-1]</li></ol><p>![image-20220217151011007](/Users/mac/Library/Application Support/typora-user-images/image-20220217151011007.png)</p></li></ul><hr><h2 id="9-区间合并"><a href="#9-区间合并" class="headerlink" title="9. 区间合并"></a>9. 区间合并</h2><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p>![image-20220217152352262](/Users/mac/Library/Application Support/typora-user-images/image-20220217152352262.png)</p><ol><li>按左端点排序</li><li>存在三种情况，分别来看如何对区间进行更新（由于已经排序且是从左到右进行扫描，因此左端点不可能在目前区间左边）<ol><li>在目前的区间内</li><li>左端点在区间内，右端点在区间外</li><li>左端点在区间外</li></ol></li></ol><hr><h1 id="第二讲-数据结构"><a href="#第二讲-数据结构" class="headerlink" title="第二讲 数据结构"></a>第二讲 数据结构</h1><ol><li>链表与邻接表</li><li>栈与队列</li><li>kmp</li></ol><p><code>使用数组模拟链表</code>：快（静态列表）</p><p>单链表：用来写邻接表（存储图和树）</p><p>双链表：优化某些问题</p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><ol><li>head指向尾节点（<strong>的下标-1</strong> ！！！）</li></ol><p>![image-20220222163913219](/Users/mac/Library/Application Support/typora-user-images/image-20220222163913219.png)</p><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>我认为需要加强印象的点：</p><ol><li>初始化，idx 0 和 1，互相指，和单链表不同的是使用循环来判断是否是尾节点，就只要看是不是指向 idx = 1(原来好像就可以理解为idx -1。。。这么一想似乎是之前的认知出现问题了)</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// 0表示左端点，1表示右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下标是k的右边插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>{</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    l[r[k]] = idx; <span class="comment">// 可以使用r[idx]这样就可以忽略顺序了</span></span><br><span class="line">    r[k] = idx;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>{</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> stk[N], tt; <span class="comment">// tt表示栈顶下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">skt[++tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出</span></span><br><span class="line">tt--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span>(tt &gt; <span class="number">0</span>) <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶</span></span><br><span class="line">stk[tt]</span><br></pre></td></tr></tbody></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队尾插入元素，队头弹出元素</span></span><br><span class="line"><span class="type">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">q[++tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出</span></span><br><span class="line">hh++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span>(hh &lt;= tt) <span class="keyword">not</span> empty;</span><br><span class="line"><span class="keyword">else</span> empty;</span><br><span class="line"><span class="comment">//取出队头元素</span></span><br><span class="line">q[hh]</span><br></pre></td></tr></tbody></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p><code>暴力做法 挖掘性质 找到某种状态 达到降低复杂度的方法</code></p><ol><li>如果要放进去的数比栈里面的数都要小（对于新的一个数进行判断的时候，肯定更加靠近新的数，而且更小），那栈里面的数都不不可能会输出，即用不到（没必要存储）</li></ol><p>![image-20220222220923613](/Users/mac/Library/Application Support/typora-user-images/image-20220222220923613.png)</p><p><img src="/Users/mac/Downloads/20201211221031165.gif" alt="20201211221031165"></p><ul><li>构建一个栈用于存储i左边的所有元素</li></ul><h2 id="单调队列（滑动窗口）"><a href="#单调队列（滑动窗口）" class="headerlink" title="单调队列（滑动窗口）"></a>单调队列（滑动窗口）</h2><p>和单调栈类似：</p><ol><li><p>只要后面有一个元素比前面的元素还要小，那么前面的就可以丢弃（之后肯定是选择后面这个更小的数）</p></li><li><p>思路：</p><p>![image-20220320181500910](/Users/mac/Library/Application Support/typora-user-images/image-20220320181500910.png)</p></li></ol><p>![image-20220320181308549](/Users/mac/Library/Application Support/typora-user-images/image-20220320181308549.png)</p><p>最小值和最大值分开来做，两个for循环完全类似，都做以下四步：</p><ol><li><p>解决队首已经出窗口的问题;</p></li><li><p>解决队尾与当前元素a[i]不满足单调性的问题;</p></li><li><p>将当前元素下标加入队尾;</p></li><li><p>如果满足条件则输出结果;</p></li></ol><blockquote><p>需要注意的细节：</p><ol><li>上面四个步骤中一定要先3后4，因为有可能输出的正是新加入的那个元素;</li><li>队列中存的是原数组的下标，取值时要再套一层，a[q[]];</li><li>算最大值前注意将hh和tt重置;</li><li>此题用cout会超时，只能用printf;</li><li>hh从0开始，数组下标也要从0开始。</li></ol></blockquote><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>实现思路：</p><ol><li>暴力算法怎么做</li><li>如何去优化</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">S[N], P[M];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">{</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s[i + j - <span class="number">1</span>] != p[j])</span><br><span class="line">        {</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><p>预处理：后缀与前缀相等（最少移动多少又能继续匹配到next[j]）公共前后缀长度数组</p><blockquote><p>next[i] = j以i为终点的后缀，和从1开始的前缀相等，且后缀的长度最长</p><p><strong>p[1, j] = p[i - j + 1, i]</strong></p></blockquote></li><li><p>如何运用这一预处理</p><blockquote><p>前面肯定是不能匹配继续走了，为了节省时间我们可以通过这个next[j]（为什么是j呢，因为在代码举例中j才是代码模版串的标识），总儿言之会得到一个长度，这就代表了上面i的前一部分next[j]长度和下面可以直接匹配，而这也刚好是之后的下标。</p></blockquote></li></ol><p>![image-20220224230512716](/Users/mac/Library/Application Support/typora-user-images/image-20220224230512716.png)</p><h2 id="Tire"><a href="#Tire" class="headerlink" title="Tire"></a>Tire</h2><blockquote><p>高效地存储和查找字符串集合的数据结构</p></blockquote><p>![image-20220226111317916](/Users/mac/Library/Application Support/typora-user-images/image-20220226111317916.png)</p><h2 id="并查集-面试重点"><a href="#并查集-面试重点" class="headerlink" title="并查集(面试重点)"></a>并查集(面试重点)</h2><blockquote><p>面试官喜欢的问题主要是代码比较短，思维性比较强</p></blockquote><p>快速的处理这样的问题（适用场景）：</p><p><strong>近乎O(1)地完成操作</strong></p><ol><li><p>将两个集合合并</p><blockquote><p>a:1000 b:2000</p><p>将a的编号改为b（改b也行），起码需要1000次</p></blockquote></li><li><p>询问两个元素是否在一个集合中</p><blockquote><p>用一个数组来存储每个元素属于哪一个集合</p><p><code>belong[x] = a  </code>：x属于a这个集合</p><p>if(belong[x] == belong[y]) O(1) 判断x和y是不是在一个集合中</p></blockquote></li></ol><p>实现思路（递归）：</p><ol><li>每一个集合用一颗树表示（不一定是二叉树）</li><li>树根的编号就是整个集合的编号</li><li>每个节点存储它的父节点，p[x]表示x的父节点</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过一个递归处理，让每一个节点的父节点，都变成了一个并查集中的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：</p><ol><li>如何判断：if(p[x] == x)（除了根节点都不相等）</li><li>如何求x的集合编号：while(p[x] != x) x = p[x];</li><li>如何合并两个集合：px是x的集合编号，py是y的集合编号，合并：p[x] = y</li><li>根据题目确定需要维护的信息</li></ol><p>优化：路经压缩（遍历一遍之后都指向父节点）</p><p>补充：按秩合并</p><h2 id="堆（完全二叉树）"><a href="#堆（完全二叉树）" class="headerlink" title="堆（完全二叉树）"></a>堆（完全二叉树）</h2><p>如何手写一个堆？</p><p>实现的功能：</p><ol><li>插入一个数<code>heap[++size] = x; up(size)</code></li><li>求集合中的最小值 <code>heap[1]</code></li><li>删除最小值 <code>heap[1] = heap[szie]; size--; down(1)</code></li></ol><p>（以下STL无法直接实现）</p><ol start="4"><li>删除任意一个元素 <code>heap[k] = heap[size]; size--; //只会执行一个 down(k); up(k)；</code></li><li>修改任意一个元素 <code>heap[k] = x; down(k); up(k); </code></li></ol><p><strong>小根堆：每一个点小于等于左右儿子</strong></p><p>堆的存储：</p><ul><li>使用一个一维数组来存</li><li>左儿子是2x，右儿子是2x+1</li><li>down（）操作、up（）操作</li></ul><p>![image-20220226145422095](/Users/mac/Library/Application Support/typora-user-images/image-20220226145422095.png)</p><p>down(x)</p><blockquote><p>数变大了，向下走，一直和最小的字节点交换位置（要保证最上面的点<strong>最小</strong>）</p></blockquote><p>up(x)</p><blockquote><p>反之，比根节点小就交换</p></blockquote><p>![image-20220226154016930](/Users/mac/Library/Application Support/typora-user-images/image-20220226154016930.png)</p><p>分析<br>i为什么从n/2开始down？</p><p>首先要明确要进行down操作时必须满足左儿子和右儿子已经是个堆。（否则down之后并不（一定）是一个堆）</p><p>开始创建堆的时候，元素是随机插入的，所以不能从根节点开始down，而是要找到满足下面三个性质的结点：</p><p>1.左右儿子满足堆的性质。</p><p>2.下标最大（因为要往上遍历）</p><p>3.不是叶结点（叶节点一定满足堆的性质）</p><p>那这个点为什么时n/2？看图。</p><p><img src="https://cdn.acwing.com/media/article/image/2021/02/03/13021_4e8b9d6e65-838%E5%A0%86%E6%8E%92%E5%BA%8F-1.png" alt="13021_4e8b9d6e65-838堆排序-1"></p><p>时间复杂度分析：</p><p>（如何建堆：最后一层可以不用管）</p><p>![image-20220226152258455](/Users/mac/Library/Application Support/typora-user-images/image-20220226152258455.png)</p><p>完整：</p><p>![image-20220227084850777](/Users/mac/Library/Application Support/typora-user-images/image-20220227084850777.png)</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], si;</span><br><span class="line"><span class="comment">// 映射关系 数的大小可能相同，但是下标都是唯一确定的</span></span><br><span class="line"><span class="comment">// ph[j] = k：第j个插入的点下标是k</span></span><br><span class="line"><span class="comment">// hp[k] = j：堆里面下标是k的点，是第j个插入的点</span></span><br><span class="line"><span class="type">int</span> ph[N], hp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>{   <span class="comment">// a，b是指堆数组中的下标</span></span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]); <span class="comment">// 交换 第k个数对下标的映射</span></span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);         <span class="comment">// 交换 下标对第k个数的映射</span></span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);           <span class="comment">// 交换 a，b的值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>{</span><br><span class="line">    <span class="comment">// 用一个t来表示最小的节点</span></span><br><span class="line">    <span class="type">int</span> t = u; </span><br><span class="line">    <span class="comment">// 左字节点存在，且左节点小于t节点的大小，t被重新复制</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= si &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 右字节点存在，且右节点小于t节点的大小，t被重新复制</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= si &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t){</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>] &gt; h[u]){</span><br><span class="line">        <span class="built_in">heap_swap</span>(u/<span class="number">2</span>, u);</span><br><span class="line">        u/=<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--){</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">"I"</span>)){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            si++; <span class="comment">// 漏掉了</span></span><br><span class="line">            m++; <span class="comment">// 第m个插入的数</span></span><br><span class="line">            ph[m] = si; hp[si] = m;</span><br><span class="line">            h[si] = x;</span><br><span class="line">            <span class="built_in">up</span>(si);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">"PM"</span>)) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">"DM"</span>)) {</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, si);</span><br><span class="line">            si--;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">"D"</span>)){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">            k = ph[k]; <span class="comment">// 找到第k个数的下标</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(k, si);</span><br><span class="line">            si--; <span class="comment">//这里已经把那个数给删除了</span></span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k); <span class="comment">// 这里的k是原来末尾的数，指的是下标k</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><strong>模拟散列表</strong>：维护的是一个集合（不重复）</p><blockquote><p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f,使得每个关键字key对应一个存储位置f (key)。查找时，根据这个确定的对应关系找到给定值key的映射f (key),若查找集合中存在这个记录，则必定在f (key)的位置上。</p></blockquote><p>![image-20220227141341865](/Users/mac/Library/Application Support/typora-user-images/image-20220227141341865.png)</p><p>作用： 把一个庞大的空间（值域）映射到一个比较小的空间</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>通过一个哈希函数h（x）：将-10的9次分到10的9次方的数映射到10的5次方</p><p>![image-20220227152849728](/Users/mac/Library/Application Support/typora-user-images/image-20220227152849728.png)</p><ul><li>添加：h(x)</li><li>查找：找一下h(x)，遍历</li><li>删除：打上布尔标记，删除的话就改一下标记，一般并不会删除</li><li>模一般取质数，冲突概率最小 <code>int k = (x % N + N) % N;</code><ul><li>这样对负数也可以进行处理（c++负数取模还是负数）</li><li>如果是（x + N）%N的话，由于x范围是10的9次分，n范围是10的五次分，所以可能还是一个负数。</li><li>哈希函数，将x映射到0-n-1</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求取质数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">100000</span>;; i++){</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j*j&lt;=i;j++){</span><br><span class="line">            <span class="keyword">if</span>(i%j == <span class="number">0</span>){</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(flag){</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="开放寻址法（用的比较多）"><a href="#开放寻址法（用的比较多）" class="headerlink" title="开放寻址法（用的比较多）"></a>开放寻址法（用的比较多）</h3><ul><li><p>只开一维数组，没有开链表，2～3倍的题目数据范围（输入的数）</p></li><li><p>处理冲突：上厕所：坑位有人就去下一个坑位</p></li><li><p>添加：找k，向后一直找到空的坑位为止</p></li><li><p>查找：找k，从前往后找，一直找到空的坑位都没找到就是不存在</p></li><li><p>删除：查找，特殊标记</p></li></ul><blockquote><p><strong>const int null = 0x3f3f3f3f 和  memset(h, 0x3f, sizeof h)之间的关系;</strong></p><ol><li><p>首先，必须要清楚memset函数到底是如何工作的先考虑一个问题，为什么memset初始化比循环更快？<br>答案：memset更快，为什么？因为memset是直接对内存进行操作。memset是按字节（byte）进行复制的</p></li><li><p>void * memset(void *_Dst,int _Val,size_t _Size);<br>这是memset的函数声明<br>第一个参数为一个指针，即要进行初始化的首地址<br>第二个参数是初始化值，注意，并不是直接把这个值赋给一个数组单元（对int来说不是这样）<br>第三个参数是要初始化首地址后多少个字节<br>看到第二个参数和第三个参数，是不是又感觉了<br>h是int类型，其为个字节， 第二个参数0x3f八位为一个字节，所以0x3f * 4(从高到低复制4份) = 0x3f3f3f3f</p></li><li><p>这也说明了为什么在memset中不设置除了-1， 0以外常见的值<br>比如1, 字节表示为00000001，memset(h, 1, 4)则表示为0x01010101</p></li></ol><p><strong>为什么要取0x3f3f3f,为什么不直接定义无穷大INF = 0x7fffffff,即32个1来初始化呢？</strong></p><ol><li><p>首先，0x3f3f3f的体验感很好，0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。</p><p>比如0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit，int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。</p><p> 但是INF不同，一旦加上某个值，很容易上溢，数值有可能转成负数，有兴趣的小伙伴可以去试一试。</p></li><li><p>0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为<strong>memset是按字节操作</strong>的（3f = 11111111），它能够对数组清零是因为0的每个字节都是0，现在如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。</p><p>在算法竞赛中，我们常常需要用到设置一个常量用来代表“无穷大”。</p><p>比如对于int类型的数，有的人会采用INT_MAX，即0x7fffffff作为无穷大。但是以INT_MAX为无穷大常常面临一个问题，即加一个其他的数会溢出。</p><p>而这种情况在动态规划，或者其他一些递推的算法中常常出现，很有可能导致算法出问题。</p><p>所以在算法竞赛中，我们常采用0x3f3f3f3f来作为无穷大。0x3f3f3f3f主要有如下好处：</p><p>0x3f3f3f3f的十进制为1061109567，和INT_MAX一个数量级，即10^9数量级，而一般场合下的数据都是小于10^9的。<br>0x3f3f3f3f * 2 = 2122219134，无穷大相加依然不会溢出。<br>可以使用memset(array, 0x3f, sizeof(array))来为数组设初值为0x3f3f3f3f，因为这个数的每个字节都是0x3f。</p></li></ol></blockquote><h3 id="字符串哈希（字符串前缀哈希法）"><a href="#字符串哈希（字符串前缀哈希法）" class="headerlink" title="字符串哈希（字符串前缀哈希法）"></a>字符串哈希（字符串前缀哈希法）</h3><ul><li><p>作用：快速判断</p></li><li><p>我们可以用前缀的哈希，用公式算出任意一个子串的哈希值</p></li><li><p>前缀的哈希值，前几位字母的哈希值</p></li><li><p>将字符串转换为P进制的数，对数取模，得到0～Q-1</p></li></ul><p><strong>注意：</strong></p><ul><li>不要映射成0     A和AA无法区分</li><li>Rp（人品）足够好、无冲突</li><li>经验值：P = 131 或 1331Q = 2^64，这种情况下99%都不会发生冲突<ul><li>前面的哈希是处理冲突，这里是假定不会产生冲突</li></ul></li></ul><p>![image-20220227214831926](/Users/mac/Library/Application Support/typora-user-images/image-20220227214831926.png)</p><ul><li>Q模2^64 使用unsigned long long存储h的值，会溢出相当于取模</li></ul><p>![image-20220227220752022](/Users/mac/Library/Application Support/typora-user-images/image-20220227220752022.png)</p><p>![字符串前缀哈希](/Users/mac/Library/Application Support/typora-user-images/字符串前缀哈希.jpeg)</p><ul><li>前缀预处理</li></ul><p>![image-20220227221035004](/Users/mac/Library/Application Support/typora-user-images/image-20220227221035004.png)</p><p>实现思路：</p><ul><li>如果两个区间的哈希值相同，则认为字符串相同</li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>![image-20220309225013089](/Users/mac/Library/Application Support/typora-user-images/image-20220309225013089.png)</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector（变长数组），倍增的思想，支持比较运算（按字典序）</p><ol><li><p>定义：<br>vector <int> a; 定义：一个vector数组a</int></p><p>vector <int> a(10); 定义：一个长度为10的vector数组a<br>vector <int> a(10,3); 定义：一个长度为10的vector数组a，并且所有元素都为3</int></int></p></li><li><p>常用函数：</p><p>size(); 返回元素个数                  时间复杂度O(1)</p><p>empty(); 返回是否是空</p><p>clear(); 清空                                队列没有</p><p>front(); 返回vector的第一个数</p><p>back(); 返回vector的最后一个数</p><p>push_back(); 向vector的最后插入一个数</p><p>pop_back(); 把vector的最后一个数删掉</p><p>begin(); vector的第0个数</p><p>end(); vector的最后一个的数的后面一个数</p></li><li><p>倍增的思想：<br>系统为某一程序分配空间是，所需时间，与空间大小无关，与申请次数有关。空间不够的时候，就数组的长度 * 2，再copy过来原来的元素。 </p></li><li><p>遍历方法</p><p>假设有个vector <int> a;</int></p><p>第一种：</p><p>​for(int i = 0;i &lt; a.size();i ++) cout&lt;&lt;a[i]&lt;&lt;” “;</p><p>第二种：</p><p>​for(vector <int>::iterator i = a.begin();i != a.end();i ++) cout&lt;&lt;*i&lt;&lt;” “;  vector <int>::iterator可以写为auto</int></int></p><p>第三种：</p><p>​for(auto  x : a) cout&lt;&lt;x&lt;&lt;” “;</p></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) a.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); i++) cout &lt;&lt; *i &lt;&lt;<span class="string">' '</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : a) cout &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>支持比较运算（按照字典序）</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>,<span class="number">3</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="built_in">puts</span>(<span class="string">"a &lt; b"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="pair-lt-int-int-gt"><a href="#pair-lt-int-int-gt" class="headerlink" title="pair<int, int>"></a>pair&lt;int, int&gt;</h3><p>pair，存储一个二元组</p><p>支持比较运算，以first为第一关键字，以second为第二关键字（按字典序）</p><ol><li><p>定义：</p><p>pair &lt;类型,类型&gt; 变量名;    两个类型可以不同</p><p>初始化方式：假设有个pair &lt;int,string&gt; p;</p><ul><li><p>第一种：p = make_pair(10,”abc”);</p></li><li><p>第二种： p = {10,”abc”);</p></li></ul></li><li><p>常用函数：</p><p>first(); 第一个元素</p><p>second(); 第二个元素</p></li><li><p>使用场景：</p><ul><li><p>某个东西两种不同属性，用pair存，需要排序，把需要用来排序的放在first里面</p></li><li><p>pair&lt;int, pair&lt;int, int&gt;&gt; p;</p></li></ul></li></ol><h3 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h3><p>​    常用函数：：<br>​        substr(); 返回每一个子串<br>​        c_str(); 返回这个string对应的字符数组的头指针<br>​        size(); 返回字母个数<br>​        length(); 返回字母个数<br>​        empty(); 返回字符串是否为空<br>​        clear(); 把字符串清空</p><h3 id="queue（队列）"><a href="#queue（队列）" class="headerlink" title="queue（队列）"></a>queue（队列）</h3><p>​    定义：：<br>​        queue &lt;类型&gt; 变量名;<br>​    常用函数：：<br>​        size(); 这个队列的长度<br>​        empty(); 返回这个队列是否为空<br>​        push(); 往队尾插入一个元素<br>​        front(); 返回队头元素<br>​        back(); 返回队尾元素<br>​        pop(); 把队头弹出<br>​        注意：队列没有clear函数！！！<br>​    清空：<br>​        变量名 = queue <int> ();<br>priority_queue（优先队列，堆）<br>​    注意：默认是大根堆！！！<br>​    定义：：<br>​        大根堆：priority_queue &lt;类型&gt; 变量名;<br>​        小根堆：priority_queue &lt;类型,vecotr &lt;类型&gt;,greater &lt;类型&gt;&gt; 变量名<br>​    常用函数：<br>​        size(); 这个堆的长度<br>​        empty(); 返回这个堆是否为空<br>​        push();往堆里插入一个元素<br>​        top(); 返回堆顶元素<br>​        pop(); 弹出堆顶元素<br>​        注意：堆没有clear函数！！！</int></p><p>stack（栈）<br>    常用函数：<br>        size(); 这个栈的长度<br>        empty(); 返回这个栈是否为空<br>        push(); 向栈顶插入一个元素<br>        top(); 返回栈顶元素<br>        pop(); 弹出栈顶元素</p><p>deque（双端队列）<br>    常用函数：<br>        size(); 这个双端队列的长度<br>        empty(); 返回这个双端队列是否为空<br>        clear(); 清空这个双端队列<br>        front(); 返回第一个元素<br>        back(); 返回最后一个元素<br>        push_back(); 向最后插入一个元素<br>        pop_back(); 弹出最后一个元素<br>        push_front(); 向队首插入一个元素<br>        pop_front(); 弹出第一个元素<br>        begin(); 双端队列的第0个数<br>        end(); 双端队列的最后一个的数的后面一个数</p><p>set，map，multiset，multimap 基于平衡二叉树（红黑树），动态维护有序序列<br>    set/multiset<br>        注意：set不允许元素重复，如果有重复就会被忽略，但multiset允许！！！<br>        常用函数：<br>            size(); 返回元素个数<br>            empty(); 返回set是否是空的<br>            clear(); 清空<br>            begin(); 第0个数，支持++或–，返回前驱和后继<br>            end(); 最后一个的数的后面一个数，支持++或–，返回前驱和后继<br>            insert(); 插入一个数<br>            find(); 查找一个数<br>            count(); 返回某一个数的个数<br>            erase();<br>                （1）输入是一个数x，删除所有x    O(k + log n)<br>                （2）输入一个迭代器，删除这个迭代器<br>            lower_bound(x); 返回大于等于x的最小的数的迭代器<br>            upper_bound(x); 返回大于x的最小的数的迭代器<br>    map/multimap<br>        常用函数：<br>            insert(); 插入一个数，插入的数是一个pair<br>            erase();<br>                （1）输入是pair<br>                （2）输入一个迭代器，删除这个迭代器<br>            find(); 查找一个数<br>            lower_bound(x); 返回大于等于x的最小的数的迭代器<br>            upper_bound(x); 返回大于x的最小的数的迭代器</p><p>unordered_set，unordered_map，unordered_muliset,unordered_multimap 基于哈希表<br>    和上面类似，增删改查的时间复杂度是O(1)<br>    不支持lower_bound()和upper_bound()</p><p>bitset 压位<br>    定义：<br>        bitset &lt;个数&gt; 变量名;<br>    支持：<br>        <del>，&amp;，|，^<br>        &gt;&gt;，&lt;&lt;<br>        ==，!=<br>        []<br>    常用函数：<br>        count(); 返回某一个数的个数<br>        any(); 判断是否至少有一个1<br>        none(); 判断是否全为0<br>        set(); 把所有位置赋值为1<br>        set(k,v); 将第k位变成v<br>        reset(); 把所有位变成0<br>        flip(); 把所有位取反，等价于</del><br>        flip(k); 把第k位取反</p><h1 id="第三讲-搜索与图论"><a href="#第三讲-搜索与图论" class="headerlink" title="第三讲 搜索与图论"></a>第三讲 搜索与图论</h1><blockquote><p>难点在于建模，如何把实际问题转换为模型</p></blockquote><p>![image-20220228210745865](/Users/mac/Library/Application Support/typora-user-images/image-20220228210745865.png)</p><ul><li>BFS：最短路径</li><li>DFS：奇怪/对空间要求比较高</li></ul><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h2><p>重要概念：</p><ol><li>回溯</li><li>剪枝</li><li>顺序，而不是思路</li></ol><p>DFS难以思考的话，从搜索树的角度考虑，每一个DFS都对应一颗搜索树</p><p><strong>重点在于剪枝和回溯：</strong></p><ol><li><p>剪枝：if语句进行判断（根据题目条件），例：如果已经出现了这个数（）就不用向下走</p></li><li><p>回溯：恢复现场，例如如果向下走，要进行标记（走过了），回溯就需要把这些标记恢复原状</p></li></ol><p>实现过程：</p><ol><li>当位数符合要求（填满）输出</li><li>位数不足需要继续填充的时候，递归</li></ol><p>![image-20220228210411343](/Users/mac/Library/Application Support/typora-user-images/image-20220228210411343.png)</p><p>![image-20220228215458970](/Users/mac/Library/Application Support/typora-user-images/image-20220228215458970.png)</p><h3 id="八皇后问题-都是DFS"><a href="#八皇后问题-都是DFS" class="headerlink" title="八皇后问题(都是DFS)"></a>八皇后问题(都是DFS)</h3><p><strong>顺序</strong></p><ol><li>每一行进行枚举</li><li>每一个格子挨个枚举</li></ol><h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索 BFS"></a>广度优先搜索 BFS</h2><blockquote><p>一般用于实现最短路问题，边权都是1的时候一般这么做（不是所有最短路都能用BFS，一般用专门的最短路算法（时间复杂度高））DP时间复杂度低</p><p>dp可以看作是一种特殊的最短路问题</p></blockquote><p>模版：</p><p>![image-20220301171624410](/Users/mac/Library/Application Support/typora-user-images/image-20220301171624410.png)</p><p>![image-20220228210456510](/Users/mac/Library/Application Support/typora-user-images/image-20220228210456510.png)</p><h2 id="树与图的深度广度优先遍历"><a href="#树与图的深度广度优先遍历" class="headerlink" title="树与图的深度广度优先遍历"></a>树与图的深度广度优先遍历</h2><h3 id="树和图的存储"><a href="#树和图的存储" class="headerlink" title="树和图的存储"></a>树和图的存储</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>{</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], ha[a] = idx++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>树是一种特殊的图：无环连通图</li><li>有向图、无向图：无向图是一种特殊的有向图</li><li>邻接矩阵：二维数组</li><li>邻接表：单链表。我们通过对每一个节点都构造出一个链表，就形成了邻接表</li></ol><p>![image-20220301212634582](/Users/mac/Library/Application Support/typora-user-images/image-20220301212634582.png)</p><h3 id="树和图的遍历（有向图的遍历）"><a href="#树和图的遍历（有向图的遍历）" class="headerlink" title="树和图的遍历（有向图的遍历）"></a>树和图的遍历（有向图的遍历）</h3><h4 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N*<span class="number">2</span>;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>{</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], ha[a] = idx++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>{</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// 已经被搜过了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i!= <span class="number">-1</span>; i = ne[i]){</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    reutrn <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h4><p><strong>重点：</strong></p><ol><li>我们可以使用DFS得到：<code>以u为根的子树点的数量</code></li><li>可以使用<code>n -  sum</code>得到除了子树外的连通块的大小（这也就意味每一个点只需要遍历一遍）</li><li>M = N * N，有N个点，add我们是要操作两次的</li></ol><p>实现思路：</p><ol><li>只要求出，每一个点，删除该点之后，其余所有连通块的点数的最大值，这之中的最小值就是答案</li><li>如何求出把点删除之后，剩余连通块的点数的最大值</li><li>我们可以通过树的深度遍历，求出每个点子树的点的数量</li><li>子树的点数可以返回回来</li><li>上面点点数可以通过 <code>n - Size[n]</code></li><li>在递归的过程中，处理每一个点的时候，都能算出在把它删除了之后，其余所有部分的连通块的大小，就能找到一个最大值。</li></ol><p>![image-20220301223156660](/Users/mac/Library/Application Support/typora-user-images/image-20220301223156660.png)</p><h4 id="宽度优先遍历（BFS）"><a href="#宽度优先遍历（BFS）" class="headerlink" title="宽度优先遍历（BFS）"></a>宽度优先遍历（BFS）</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> g[N][N], d[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> dx[] = {<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>}, dy[] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>};</span><br><span class="line">    queue &lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : d) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : v) {</span><br><span class="line">            x = - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>({<span class="number">0</span>, <span class="number">0</span>});</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>) {</span><br><span class="line">                d[x][y] = d[t.first][t.second]  + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>({x, y});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="图中点的层次遍历"><a href="#图中点的层次遍历" class="headerlink" title="图中点的层次遍历"></a>图中点的层次遍历</h4><p>所有边点长度都为1，说明可以使用BFS</p><p>![image-20220302094855148](/Users/mac/Library/Application Support/typora-user-images/image-20220302094855148.png)</p><h2 id="拓扑排序（图的宽搜的应用）"><a href="#拓扑排序（图的宽搜的应用）" class="headerlink" title="拓扑排序（图的宽搜的应用）"></a>拓扑排序（图的宽搜的应用）</h2><ol><li>针对有向图</li><li>所有的边都是从前指向后</li><li>有环一定没有拓扑序列</li><li>有向无环图也叫拓扑图</li><li>度数：入度（有多少条边指向自己） 出度（有多少边出去）</li><li>有向无环图至少有一个入度为0点点</li><li>出队的顺序恰好就是拓扑序列</li></ol><p>![image-20220302101020476](/Users/mac/Library/Application Support/typora-user-images/image-20220302101020476.png)</p><p>实现思路：</p><ol><li><p>入度为0，即为起点，排在当前最前的位置</p><ol><li>最开始的入度为0度点怎么找呢？ 遍历一遍d[N]</li></ol></li><li><p>环上没有一个点能满足入度为0点条件</p></li></ol><p>![image-20220302102727282](/Users/mac/Library/Application Support/typora-user-images/image-20220302102727282.png)</p><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><p>难点在建图，而不是正确性，重点在于算法的实现思路以及代码的模版</p><p>![image-20220302132449948](/Users/mac/Library/Application Support/typora-user-images/image-20220302132449948.png)</p><p>分类：</p><ol><li><p>单源最短路问题：从一个点到多个点到最短路径</p><ol><li><p>所有边权都是正数</p><blockquote><p>朴素Dijkstra算法 O(n^2) 适合：稠密图</p><p>堆优化版的Dijkstra算法 O(mlogn) </p></blockquote></li><li><p>存在负权边</p><blockquote><p>Bellman-Ford O(nm)</p><p>SPFA 一般是O(m) 最坏O(nm)</p></blockquote></li></ol></li><li><p>多源汇最短路问题：起点和终点都是不确定的</p><ol><li>Floyd算法 O(n^3)</li></ol></li></ol><h3 id="1-Dijkstra"><a href="#1-Dijkstra" class="headerlink" title="1. Dijkstra"></a>1. Dijkstra</h3><p>边数很多，稠密图，使用邻接矩阵</p><ol><li><p>初始化距离<code>dis[i] = 0, dis[i] = +∞</code>，s为当前已确定的最短距离的点的集合（从一个固定点）</p><blockquote><p>为什么这里初始化dis数组的时候是用0x3f，之前都是用-1？</p><p>因为之前只需要确定一次路径（-1和0x3f都行），而这里需要连续的迭代去得到最短的路径，直接初始化（无穷大）可以减少判断条件</p></blockquote></li><li><p>一个迭代的过程：每次确定一个点到起点的最短路，确定当前还没确定的点中距离最小的点（一定是最短路，基于贪心）</p><ol><li><p><code>for(int i = 1; i &lt;= n; i++)</code></p><ol><li><p>找到不在s中的距离起点最近的点 for 1-n</p></li><li><p>将t放到s中去</p></li><li><p>用t更新其他所有点的距离 for 1-n</p></li></ol><p>![image-20220302144658826](/Users/mac/Library/Application Support/typora-user-images/image-20220302144658826.png)</p></li></ol></li></ol><p>![image-20220302133314333](/Users/mac/Library/Application Support/typora-user-images/image-20220302133314333.png)</p><h4 id="朴素版Dijkstra"><a href="#朴素版Dijkstra" class="headerlink" title="朴素版Dijkstra"></a>朴素版Dijkstra</h4><blockquote><p>适合稠密图（使用邻接矩阵进行存储）</p><blockquote><p>时间复杂度分析</p><p>寻找路径最短的点：O(n^2)</p><p>加入集合S：O(n)</p><p>更新距离：O(m)</p><p>所以总的时间复杂度为O(n^2)</p></blockquote></blockquote><p><strong>思路：</strong></p><p>我认为还需要注意的一点是，<strong>这里没有把1号放入s集合（确定了最短路径的集合）中</strong></p><ol><li>首先可以简化操作，不需要多写一轮用1（起点）来更新其他点到起点的距离</li><li>其次如果起点到终点的距离就是最短的距离的话，又回需要更加复杂的判断条件使之不进行后续的更新</li></ol><blockquote><p> 集合S为已经确定最短路径的点集。</p></blockquote><ol><li>初始化距离<br>一号结点的距离为零，其他结点的距离设为无穷大（看具体的题）。</li><li>循环n次，每一次将集合S之外距离最短X的点加入到S中去（这里的距离最短指的是距离1号点最近。点X的路径一定最短，基于贪心，严格证明待看）。然后用点X更新X邻接点的距离。</li></ol><h4 id="堆优化版Dijkstra"><a href="#堆优化版Dijkstra" class="headerlink" title="堆优化版Dijkstra"></a>堆优化版Dijkstra</h4><blockquote><p>适合稀疏图（使用邻接表进行存储，多加一个权重）</p><blockquote><p>时间复杂度分析</p><p>寻找路径最短的点：O(n)</p><p>加入集合S：O(n)</p><p>更新距离：O(mlogn)</p></blockquote></blockquote><p><strong>思路：</strong></p><blockquote><p>堆优化版的dijkstra是对朴素版dijkstra进行了优化，在朴素版dijkstra中时间复杂度最高的寻找距离最短的点O(n^2)可以使用最小堆优化。</p></blockquote><ol><li>一号点的距离初始化为零，其他点初始化成无穷大。</li><li>将一号点放入堆中。</li><li>不断循环，直到堆空。每一次循环中执行的操作为：<br>弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点的最短路径已经确定）。<br>用该点更新临界点的距离，若更新成功就加入到堆中。</li></ol><p><strong>重点：</strong></p><ol><li><p>STL库中的堆不可以实现对容易一个点就行修改，只能添加（产生冗余）</p></li><li><p>heap({distance, ver}) 这样就会是按照最短距离排序</p></li><li><p>由于只能添加，所以我们通过st进行判断是否已经确定了最短路径（就不再遍历这个点了）</p><blockquote><p>如果更新会怎么样？</p><p>由于每次都用最短的距离更新，所以重复的点并不会得到更好的结果，反而加大了工作量</p></blockquote></li></ol><h3 id="2-bellman-ford"><a href="#2-bellman-ford" class="headerlink" title="2. bellman-ford"></a>2. bellman-ford</h3><blockquote><p>处理有负权边的情况</p><p>如果有负权回路，则不一定存在最短距离</p><ul><li>无最短距离：通向n点的路径上有负环![image-20220303131204859](/Users/mac/Library/Application Support/typora-user-images/image-20220303131204859.png)</li><li>有最短距离：虽然有负环嘛，但是到不了n![image-20220303132314138](/Users/mac/Library/Application Support/typora-user-images/image-20220303132314138.png)</li></ul><p>可以求负环，但是时间复杂度比较高</p><p>一般情况下差与SPFA算法</p><p>但是在有边数限制的最短路里面，只能用到这个算法</p></blockquote><p>迭代k次：从1号点，经过不超过k条边，走到每个点点最短距离</p><p>n次迭代之后，又更新了边的话，就说明存在一条边数为n的最短路径（没有第n+1个点），就说明存在负环。每次有更新的话最短路径的边数都会多一</p><p>![image-20220303130928885](/Users/mac/Library/Application Support/typora-user-images/image-20220303130928885.png)</p><p>使用backup来防止串联</p><p>![image-20220303134420226](/Users/mac/Library/Application Support/typora-user-images/image-20220303134420226.png)</p><p>注意：</p><p>为什么是dist[n]&gt;0x3f3f3f3f/2， 而不是dist[n]&gt;0x3f3f3f3f</p><p>5号节点距离起点的距离是无穷大，利用5号节点更新n号节点距离起点的距离，将得到109−2<br>, 虽然小于109<br>, 但并不存在最短路，(在边数限制在k条的条件下)。</p><h3 id="3-spfa"><a href="#3-spfa" class="headerlink" title="3. spfa"></a>3. spfa</h3><blockquote><p>对Bellman-Ford优化（宽度优先搜索）</p><p>没有负环的最短路就能使用</p></blockquote><p>实现思路：</p><ol><li><p>只有a变小了，b才可能变小</p><p>![image-20220303164342054](/Users/mac/Library/Application Support/typora-user-images/image-20220303164342054.png)</p></li><li><p>更新过谁，就拿他去更新别人</p></li></ol><p>![image-20220303162737129](/Users/mac/Library/Application Support/typora-user-images/image-20220303162737129.png)</p><h3 id="4-Floyd"><a href="#4-Floyd" class="headerlink" title="4. Floyd"></a>4. Floyd</h3><blockquote><p>邻接矩阵存储</p><p>基于动态规划</p></blockquote><p>![image-20220303191101799](/Users/mac/Library/Application Support/typora-user-images/image-20220303191101799.png)</p><h2 id="最小生成树（无向图"><a href="#最小生成树（无向图" class="headerlink" title="最小生成树（无向图"></a>最小生成树（无向图</h2><p>![image-20220304103627091](/Users/mac/Library/Application Support/typora-user-images/image-20220304103627091.png)</p><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><h4 id="1-朴素版Prim（稠密图）"><a href="#1-朴素版Prim（稠密图）" class="headerlink" title="1. 朴素版Prim（稠密图）"></a>1. 朴素版Prim（稠密图）</h4><ul><li>区别：Dijkstra是到<strong>起点</strong>的距离最小值![image-20220304104824524](/Users/mac/Library/Application Support/typora-user-images/image-20220304104824524.png)</li></ul><h4 id="2-堆优化Prim（稀疏图）"><a href="#2-堆优化Prim（稀疏图）" class="headerlink" title="2. 堆优化Prim（稀疏图）"></a>2. 堆优化Prim（稀疏图）</h4><ul><li>百分百不会用。。。不讲了</li></ul><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>![image-20220306143103630](/Users/mac/Library/Application Support/typora-user-images/image-20220306143103630.png)</p><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>![image-20220304103912860](/Users/mac/Library/Application Support/typora-user-images/image-20220304103912860.png)</p><h3 id="染色体判定二分图（DFS）"><a href="#染色体判定二分图（DFS）" class="headerlink" title="染色体判定二分图（DFS）"></a>染色体判定二分图（DFS）</h3><p><strong>染色法</strong>性质：</p><ul><li>将所有点分成两个集合，使得所有边只出现在集合之间，就是二分图</li><li>二分图：一定不含有奇数环，可能包含长度为偶数的环， 不一定是连通图</li><li>边的两边颜色不一样</li></ul><img src="/Users/mac/Library/Application Support/typora-user-images/image-20220306143317397.png" alt="image-20220306143317397" style="zoom:50%;"><p><strong>DFS版本</strong>代码思路：</p><ul><li>染色可以使用<strong>1和2区分不同颜色</strong>，用<strong>0表示未染色</strong></li><li>遍历所有点，每次将<strong>未染色</strong>的点进行dfs, 默认染成1或者2</li><li>由于某个点染色成功不代表整个图就是二分图**,因此只有某个点染色失败才能立刻break/return**</li><li>染色失败相当于<strong>存在相邻的2个点染了相同的颜色</strong></li></ul><p><strong>BFS版本</strong>代码思路 –需要手写再次实现</p><ul><li>颜色 1 和 2 表示不同颜色, 0 表示 未染色</li><li>定义queue是存PII，表示 &lt;点编号, 颜色&gt;,</li><li>同理，遍历所有点, 将未染色的点都进行bfs</li><li>队列初始化将第i个点入队, 默认颜色可以是1或2<ul><li>while (队列不空)</li><li>每次获取队头t, 并遍历队头t的所有邻边<ul><li>若邻边的点未染色则染上与队头t<strong>相反</strong>的颜色，并添加到队列（后续继续遍历）</li><li>若邻边的点已经染色且与队头t的颜色<strong>相同</strong>, 则返回false</li></ul></li></ul></li></ul><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><img src="/Users/mac/Library/Application Support/typora-user-images/匈牙利.gif"><h1 id="第五讲-动态规划"><a href="#第五讲-动态规划" class="headerlink" title="第五讲 动态规划"></a>第五讲 动态规划</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h2 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h2><h2 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h2><h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h1 id="第六讲-贪心"><a href="#第六讲-贪心" class="headerlink" title="第六讲 贪心"></a>第六讲 贪心</h1><blockquote><p>区间问题一般先排序，端点从小到大排序</p></blockquote><ul><li>贪心的思想是局部最优解，只在乎眼前最好的方法</li></ul><p>![image-20220310163414689](/Users/mac/Library/Application Support/typora-user-images/image-20220310163414689.png)</p><ul><li>需要证明Ans = cnt：Ans为目标值（可行解中的最优解，本题为最小值） cnt是我们当前这种选取方案的解。<ul><li>Ans &lt;= cnt：cnt 是一种可行方案， ans是可行方案的最优解，也就是最小值。</li><li>Ans &gt;= cnt：cnt可行方案是一个区间集合，区间从小到大排序，两两之间不相交。所以覆盖每一个区间至少需要cnt个点。</li></ul></li></ul><h2 id="最大不相交区间数量"><a href="#最大不相交区间数量" class="headerlink" title="最大不相交区间数量"></a>最大不相交区间数量</h2><ul><li>证明：Ans = cnt<ul><li>Ans &gt;= cnt：按照套路选出的区间，相互之间没有交集，是一种可行方案，答案是可行方案的最大值。</li><li>Ans &lt;= cnt：假设Ans大于cnt（有Ans个区间没有交集），即可以选出比cnt更多的（Ans个点才能覆盖所有区间）不相交区间，与实际不符（只需要cnt个点就可以覆盖掉所有不相交的区间）</li></ul></li></ul><h2 id="区间分组"><a href="#区间分组" class="headerlink" title="区间分组"></a>区间分组</h2><p>![ ](/Users/mac/Library/Application Support/typora-user-images/image-20220310205231504.png)</p><ul><li><p>证明：Ans = cnt，Ans是答案，cnt表示我们这一方法得到的答案</p><ul><li><p>Ans &lt;= cnt：cnt是一种合法方案</p></li><li><p>Ans &gt;= cnt：选取一个特殊的时刻，整个cnt个区间都有公共点，所以每一个区间都不会在一个组里面。Ans &gt;= cnt。</p><p>![image-20220310210315390](/Users/mac/Library/Application Support/typora-user-images/image-20220310210315390.png)</p></li></ul></li><li><p>如何判断是否存在一个组：（最小的）Max_r &lt; L[i]</p></li></ul><h2 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h2><blockquote><p>ans可以逐步替换成最优解</p></blockquote><p>![image-20220311165826346](/Users/mac/Library/Application Support/typora-user-images/image-20220311165826346.png)</p><ul><li><p>证明：Ans = cnt</p><ul><li><p>Ans &lt;= cnt：cnt是一种可行方案，Ans是最小值</p></li><li><p>Ans &gt;= cnt：反证法。假设存在ans &lt; cnt，那么cnt里面有一点区间是不满足我们选择规则的，cnt会可以换成ans中的部分区间，最后会ans = cnt，产生矛盾，所以得证。</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一讲-基础算法&quot;&gt;&lt;a href=&quot;#第一讲-基础算法&quot; class=&quot;headerlink&quot; title=&quot;第一讲 基础算法&quot;&gt;&lt;/a&gt;第一讲 基础算法&lt;/h1&gt;&lt;p&gt;主要思想：代码为什么是对的、为什么这样写，需要有一个深刻的理解。&lt;/p&gt;
&lt;p&gt;课后：&lt;/p</summary>
      
    
    
    
    <category term="算法" scheme="https://zwh1y.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="基础" scheme="https://zwh1y.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="模版" scheme="https://zwh1y.github.io/tags/%E6%A8%A1%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>再不睡觉我就要猝死了</title>
    <link href="https://zwh1y.github.io/2022/05/08/%E5%86%8D%E4%B8%8D%E7%9D%A1%E8%A7%89%E6%88%91%E5%B0%B1%E8%A6%81%E7%8C%9D%E6%AD%BB%E4%BA%86/"/>
    <id>https://zwh1y.github.io/2022/05/08/%E5%86%8D%E4%B8%8D%E7%9D%A1%E8%A7%89%E6%88%91%E5%B0%B1%E8%A6%81%E7%8C%9D%E6%AD%BB%E4%BA%86/</id>
    <published>2022-05-07T20:10:46.000Z</published>
    <updated>2022-05-08T01:57:38.039Z</updated>
    
    <content type="html"><![CDATA[<p>​hexo博客算是会生成了，接下来选用主题和如何规划分类是一个难题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​	hexo博客算是会生成了，接下来选用主题和如何规划分类是一个难题&lt;/p&gt;
</summary>
      
    
    
    
    <category term="生活" scheme="https://zwh1y.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="杂谈" scheme="https://zwh1y.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>不想玩啦</title>
    <link href="https://zwh1y.github.io/2022/05/08/%E4%B8%8D%E6%83%B3%E7%8E%A9%E5%95%A6/"/>
    <id>https://zwh1y.github.io/2022/05/08/%E4%B8%8D%E6%83%B3%E7%8E%A9%E5%95%A6/</id>
    <published>2022-05-07T18:41:01.000Z</published>
    <updated>2022-05-08T01:57:34.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复旦小子-wsb"><a href="#复旦小子-wsb" class="headerlink" title="复旦小子 wsb"></a>复旦小子 wsb</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复旦小子-wsb&quot;&gt;&lt;a href=&quot;#复旦小子-wsb&quot; class=&quot;headerlink&quot; title=&quot;复旦小子 wsb&quot;&gt;&lt;/a&gt;复旦小子 wsb&lt;/h1&gt;</summary>
      
    
    
    
    <category term="生活" scheme="https://zwh1y.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="杂谈" scheme="https://zwh1y.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zwh1y.github.io/2022/05/08/hello-world/"/>
    <id>https://zwh1y.github.io/2022/05/08/hello-world/</id>
    <published>2022-05-07T18:39:38.161Z</published>
    <updated>2022-05-07T18:39:38.161Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
