<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一讲 基础算法（算法基础课）</title>
      <link href="/2022/05/15/%E7%AC%AC%E4%B8%80%E8%AE%B2%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%EF%BC%89/"/>
      <url>/2022/05/15/%E7%AC%AC%E4%B8%80%E8%AE%B2%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本系列源自：y总 算法基础课，收获很大，强烈推荐。</p><p>链接：<a href="https://www.acwing.com/activity/content/introduction/11/">https://www.acwing.com/activity/content/introduction/11/</a></p><p>下面是我对于y总课程内容的总结，以及一些个人的思考</p><span id="more"></span><div class="story post-story"><h2 id="第一讲-基础算法"><a href="#第一讲-基础算法" class="headerlink" title="第一讲 基础算法"></a>第一讲 基础算法</h2><p>主要思想：代码为什么是对的、为什么这样写，需要有一个深刻的理解。</p><p>课后：</p><ul><li>背过代码（快速的默写出模版，调试之后能过）</li><li>课后习题 （）每个题目写个3-5遍</li></ul></div><div class="story post-story"><h2 id="1-快速排序（已过）"><a href="#1-快速排序（已过）" class="headerlink" title="1. 快速排序（已过）"></a>1. 快速排序（已过）</h2><p>思想：<strong>基于分治</strong></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><img src="https://s2.loli.net/2022/05/15/7iM9lZhGqBmOgK1.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/7iM9lZhGqBmOgK1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220210144232572" style="zoom:50%;" /><ul><li><p>思想：</p><ul><li>确定分界点：q[l] q[r] q[l + r &gt;&gt; 1]</li><li><strong>调整区间</strong>：x左边的数都小于等于x， x右边的数都大于等于x</li><li>递归处理左右两段</li></ul></li><li><p><strong>复习出现的错误：</strong></p><ol><li><p>do while循环不熟练，do后面的i++也需要加上；</p></li><li><p>递归处理的时候越界了，写的分界点是j-1和j？？？（暂时不知道为什么）经过测试，使用i-1和i分界也会出错，使用 + 1就不会。</p></li><li><p><code>x = l + r &gt;&gt; 1</code>出错，如果我们不使用<code>x = q[l + r &gt;&gt; 1]</code>。这里如果每次记住的是下标，那么每次都是那个固定的下标，然而下标的固定并不能保证下标里面存放的值是固定的，尤其是在进行swap交换的过程中，可能会出现对应的值发生了变化，如果此时坚持使用q[下标] 当下标对应的位置改变的时候q[下标]第k个数也会改变，但是我们选点的时候是根据一个固定的值，左边全部小于等于x右边全部大于等于x。违背了这个初衷就会WA</p><blockquote><p>我们每次while循环需要用同一个值来进行比较，如果保存下标的话，在交换后可能导致同一个while循环中比较的数改变，从而造成错误。</p></blockquote></li></ol></li></ul><hr><img src="https://s2.loli.net/2022/05/15/FkJ3mnrMVW2Kdgf.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/FkJ3mnrMVW2Kdgf.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309091843756" style="zoom:50%;" /><ul><li>Sl和Sr表示的是个数</li></ul><p><strong>重点思想：</strong></p><ul><li>多了一个k，排序之后，通过左边的数和右边数的个数辅助判断</li></ul></div><div class="story post-story"><h2 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2. 归并排序"></a>2. 归并排序</h2><p><strong>思想：基于分治</strong></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><img src="https://s2.loli.net/2022/05/15/Yt67jOa8AUIyluL.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/Yt67jOa8AUIyluL.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220210151729930" style="zoom:50%;" /><ul><li><p>思想：</p><ul><li>确定分界点：mid  &#x3D; (l + r) &gt;&gt; 2 <em>和快速排序的区别是快速排序是数组中的值，而这里用的是下标</em></li><li>递归排序 left right</li><li><strong>归并</strong> 合并两个有序的数组</li></ul></li><li><p>代码实现：</p></li></ul><ol><li>递归终止情况</li><li>分成子问题，递归处理子问题</li><li>合并子问题</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归的终止情况</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：分成子问题</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：递归处理子问题</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid ), <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：合并子问题</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>, tmp[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>边界分析：</strong></p><ul><li><p><strong>为什么不用 mid - 1 作为分隔线呢？</strong></p><p>即 merge_sort(q, l, mid - 1 ), merge_sort(q, mid, r)</p><p>因为 mid &#x3D; l + r &gt;&gt; 1 是向下取整，mid 有可能取到 l (数组只有两个数时)，造成无限划分</p></li><li><p><strong>解决办法:</strong> mid 向上取整就可以了, 即 mid &#x3D; l + r + 1 &gt;&gt; 1,如下所示:</p></li></ul></li></ul><h3 id="逆序对的数量"><a href="#逆序对的数量" class="headerlink" title="逆序对的数量"></a>逆序对的数量</h3><hr></div><div class="story post-story"><h2 id="3-二分"><a href="#3-二分" class="headerlink" title="3. 二分"></a>3. 二分</h2><p>二分的本质是二段性</p><p>有单调性一定可以二分，没有单调性也有可能可以二分</p><p>重点：<br>    1. check需要自己定义去找一个最合适的</p><h3 id="数的范围"><a href="#数的范围" class="headerlink" title="数的范围"></a>数的范围</h3><img src="https://s2.loli.net/2022/05/15/mqiz45b3dF1Wwx8.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/mqiz45b3dF1Wwx8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220327204537182" style="zoom: 33%;" /><img src="https://s2.loli.net/2022/05/15/EYqt7HbdGZCSkr5.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/EYqt7HbdGZCSkr5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220327224242273" style="zoom:50%;" /><img src="https://s2.loli.net/2022/05/15/dg1cDVzJaFUiw3Y.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/dg1cDVzJaFUiw3Y.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220210160017818" style="zoom: 50%;" /><p>图示如下：</p><img src="https://s2.loli.net/2022/05/15/bz1FgLEjnGXIrD5.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/bz1FgLEjnGXIrD5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220315221453548" style="zoom: 33%;" /><img src="https://s2.loli.net/2022/05/15/pvdBYt2wx1zIRah.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/pvdBYt2wx1zIRah.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220315210734201" style="zoom:50%;" /><ul><li><p>mid &#x3D; l + r  + 1&gt;&gt; 1     找小于等于x的数，判断 mid &lt;&#x3D; x是否成立</p><p>if(check(mid))  true  [mid, r]      更新：l &#x3D; mid</p><p>​                          false [l, mid - 1] 更新：r &#x3D; mid - 1</p></li></ul><img src="https://s2.loli.net/2022/05/15/ZS8X7FxwoD5jzJW.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/ZS8X7FxwoD5jzJW.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220315211523555" style="zoom:50%;" /><ul><li><p>mid &#x3D;  l + r &gt;&gt; 1         找大于等于x的数，判断mid &gt;&#x3D; x是否成立</p><p>if(check(mid)) true [l, mid]        更新：r &#x3D; mid</p><p>​                     false[mid + 1, r] 更新：l &#x3D; mid + 1</p></li><li><p>是否加1:看更新区间，如果是<strong>l &#x3D; mid</strong>就需要补一个 + 1，如果是<strong>r&#x3D;mid</strong>就不需要补上+ 1。</p></li><li><p>如何理解mid +1还是-1:</p><ul><li>判断q[mid] &gt;&#x3D; x，不满足的话，mid就不会在区间内,更新后的区间要靠近r，所以要让 l &#x3D; mid + 1</li><li>判断q[mid] &lt;&#x3D; x，不满足的话，mid就不会在区间内,更新后的区间要靠近l，所以要让 r &#x3D; mid - 1</li></ul></li></ul><h3 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h3><p>浮点数二分，没有精度问题，好写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>)&#123; <span class="comment">// 精度提高，比输出多2就没问题</span></span><br><span class="line">        <span class="type">double</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环写法(区间变为原来的100分之一)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="story post-story"><h2 id="4-高精度"><a href="#4-高精度" class="headerlink" title="4. 高精度"></a>4. 高精度</h2><p>c++需要 </p><p>java中有大整数类 python默认是无限大</p><p>A &lt;&#x3D; 10与len(A) &lt; 10 0-9999999999</p><p>都是使用大数组进行存储</p><p>处理中使用到了A[i] - ‘0’（自动转换为ASCII码的值相减）相减得到的就是数值</p><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><ul><li>大数组存储</li><li>模拟人工加法的过程 每次计算的时候使用到了三个数Ai Bi 以及 t（进位）</li><li>使用数组表示A B C（使用vector数组就可以不需要额外使用变量来获取长度）</li><li>使用一个t来表示进位</li></ul><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><img src="https://s2.loli.net/2022/05/15/id8YUneDamqOLKx.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/id8YUneDamqOLKx.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220212143839690" style="zoom:50%;" /><ul><li>需要保证 A &gt;&#x3D; B,  如果A &lt;B，则计算B-A加上一个负号</li><li>设计到负数就使用绝对值计算出再进行符号判断</li><li>t表示是当前位数的数值，以及用来判断是否借位（取值为1或者0）</li><li>注意：去掉前导0（除非数值为0）</li></ul><h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><ul><li>与高精度加法类似，利用到t来计算进位</li></ul><h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><hr></div><div class="story post-story"><h2 id="5-前缀和与差分（其实是一对逆运算）"><a href="#5-前缀和与差分（其实是一对逆运算）" class="headerlink" title="5. 前缀和与差分（其实是一对逆运算）"></a>5. 前缀和与差分（其实是一对逆运算）</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>注意：</p><ol><li>就是算出前n项和，比较简单</li><li>题目一遍问的是第几个数到第几个数，所以从1开始会比较好理解，不容易出错。</li></ol><img src="https://s2.loli.net/2022/05/15/mtxKPwlbcgG9k6a.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/mtxKPwlbcgG9k6a.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220212194305121" style="zoom:50%;" /><h3 id="子矩阵的和"><a href="#子矩阵的和" class="headerlink" title="子矩阵的和"></a>子矩阵的和</h3><p>注意：</p><ol><li>输出的计算：<code>s[x2][y2] - s[x2][y1 - 1] -s[x1 - 1][y2] + s[x1 - 1][y1 - 1]</code></li></ol><img src="https://s2.loli.net/2022/05/15/pPd5vJjnm8BhNG6.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/pPd5vJjnm8BhNG6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220214104150816" style="zoom:50%;" /><h3 id="差分（不需要考虑如何构造，只要考虑如何）"><a href="#差分（不需要考虑如何构造，只要考虑如何）" class="headerlink" title="差分（不需要考虑如何构造，只要考虑如何）"></a>差分（不需要考虑如何构造，只要考虑如何）</h3><p>差分数组是一个数组 存放的是<strong>相邻数据</strong>之间的<strong>差值</strong></p><ul><li><p>假象一个b数组，b的前缀和是a，b被称为a的差分</p></li><li><p>用处：O(1)的时间解决原来O(n)的问题</p></li><li><p>**假定a1 - an都是0，差分数组也就是都是0，假定插入了n次插入操作，每次让原数组[n, n]的区间插入a[n]**：插入操作操作就可以直接使用到公式（在原数组a的一段区间中插入值）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><img src="https://s2.loli.net/2022/05/15/Gis59jtgKvmqV6a.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/Gis59jtgKvmqV6a.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220214113403124" style="zoom: 50%;" /><img src="https://s2.loli.net/2022/05/15/SDKLqCmt235hbRE.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/SDKLqCmt235hbRE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220214113811487" style="zoom:50%;" /><h3 id="差分矩阵（二维差分）"><a href="#差分矩阵（二维差分）" class="headerlink" title="差分矩阵（二维差分）"></a>差分矩阵（二维差分）</h3><ul><li><p>令aij等于0，显然bij等于零，再根据aij实际值，插入一遍就好了</p></li><li><p>公式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] +=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><img src="https://s2.loli.net/2022/05/15/iw8mlG3hpKT1ZBr.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/iw8mlG3hpKT1ZBr.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220214155746725" style="zoom:50%;" /><hr></div><div class="story post-story"><h2 id="6-双指针算法"><a href="#6-双指针算法" class="headerlink" title="6. 双指针算法"></a>6. 双指针算法</h2><p><strong>核心思想：</strong>将一个复杂度更高的计算，优化</p><img src="https://s2.loli.net/2022/05/15/FX6jPSHtcN7EZyL.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/FX6jPSHtcN7EZyL.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220318204523962" style="zoom:50%;" /><ul><li><p>两大类：</p><ul><li>归并排序</li><li>快速排序</li></ul></li><li><p>j表示j往左，最左能到什么地方</p></li><li><p>先写下面的模版，再如何去做</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j++;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 每道题的具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>核心思想：</p><ul><li>通过暴力先写暴力做法</li><li>在枚举的时候看，i和j的单调关系</li><li>利用单调关系把枚举数量从n^2变成n</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt; n; j++)</span><br><span class="line">      <span class="built_in">O</span>(n^<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 将上面的朴素算法优化到O(n)</span></span><br></pre></td></tr></table></figure></li><li><p>简单的例题：将每个单词分别输出且各占一行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gets</span>(str);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; str[j] != <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这道题的具体逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; j; k++) cout &lt;&lt; str[k];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h3><p><strong>核心思路：</strong></p><ol><li>遍历数组a中的每一个元素a[i], 对于每一个i，找到j使得双指针[j, i]<strong>维护的是以 a[i]结尾 的最长连续不重复子序列</strong>，长度为i - j + 1, 将这一长度与r的较大者更新给r。</li><li>对于每一个i，如何确定j的位置：由于[j, i - 1]是前一步得到的最长连续不重复子序列，所以如果[j, i]中有重复元</li><li>素，一定是a[i]，因此右移j直到a[i]不重复为止（由于[j, i - 1]已经是前一步的最优解，此时j只可能右移以剔除重复元素a[i]，不可能左移增加元素，因此，j具有“单调性”、本题可用双指针降低复杂度）。</li><li>用数组s记录子序列a[j ~ i]中各元素出现次数，遍历过程中对于每一个i有四步操作：cin元素a[i] -&gt; 将a[i]出现次数s[a[i]]加1 -&gt; 若a[i]重复则右移j（s[a[j]]要减1） -&gt; 确定j及更新当前长度i - j + 1给r。</li></ol><p><strong>注意细节：</strong></p><ol><li>当a[i]重复时，先把a[j]次数减1，再右移j。</li></ol><img src="https://s2.loli.net/2022/05/15/QzkagsRwU2x9Bmd.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/QzkagsRwU2x9Bmd.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220216145058032" style="zoom: 67%;" /><ul><li><p>暴力：遍历起点和终点(i在右边，j在左边)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 朴素做法： O(n^2)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(i, j))&#123;</span><br><span class="line">      res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双指针算法：</p><ul><li>找到单调性等<strong>新的性质</strong>，简化时间复杂度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>， j = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">  <span class="keyword">while</span>(j &lt;= i &amp;&amp; <span class="built_in">check</span>(j, i)) j++;</span><br><span class="line">  res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数组元素的目标和"><a href="#数组元素的目标和" class="headerlink" title="数组元素的目标和"></a>数组元素的目标和</h3><h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h3><hr></div><div class="story post-story"><h2 id="7-位运算"><a href="#7-位运算" class="headerlink" title="7. 位运算"></a>7. 位运算</h2><ul><li><p>n的二进制表示中第k位是几（个位是第0位）</p><ol><li>先把第k位移到最后一位 n &gt;&gt; k</li><li>看各位是几 x&amp;1</li><li>结合1、2之后，常用操作：n &gt;&gt; k &amp; 1</li></ol></li><li><p>lowbit(x)：返回x的最后一位1</p><img src="https://s2.loli.net/2022/05/15/cBxZDkuTUVe4yoX.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/cBxZDkuTUVe4yoX.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220216162301007" style="zoom: 50%;" /><p>x &#x3D; 1010        lowbit(x) &#x3D; 10(2)</p><p>x &#x3D; 101000   lowbit(x) &#x3D; 1000(4)</p><ol><li>实现原理：x&amp;-x </li><li>-x &#x3D; <del>x + 1所以x&amp;-x &#x3D; x&amp;(</del>x+1)</li></ol></li></ul><h3 id="二进制中1的个数-上述应用"><a href="#二进制中1的个数-上述应用" class="headerlink" title="二进制中1的个数(上述应用)"></a>二进制中1的个数(上述应用)</h3><img src="https://s2.loli.net/2022/05/15/nvYOA1fPwgFxycZ.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/nvYOA1fPwgFxycZ.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220216162952102" style="zoom:50%;" /><hr></div><div class="story post-story"><h2 id="8-离散化（整数有序）"><a href="#8-离散化（整数有序）" class="headerlink" title="8. 离散化（整数有序）"></a>8. 离散化（整数有序）</h2><ul><li>值域很大，但是内容稀疏</li><li>将下标离散化</li></ul><img src="https://s2.loli.net/2022/05/15/zVUojS12nIQH4AN.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/zVUojS12nIQH4AN.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220227143216831" style="zoom: 33%;" /><h3 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h3><blockquote><p>将下标离散化之后，离散化之后的下标插入对应的值，同时离散化的下标包括查找的区间，形成一个新的数组进行处理。</p></blockquote><img src="https://s2.loli.net/2022/05/15/nph8DtVP3jkTorw.jpg" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/nph8DtVP3jkTorw.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="区间和" style="zoom: 25%;" /><img src="https://s2.loli.net/2022/05/15/9zw5iPFakSs7CTD.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/9zw5iPFakSs7CTD.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220216165051104" style="zoom:50%;" /><ul><li><p>将<strong>下标</strong>拿过来排序，映射到从1开始的自然数，利用前缀和计算</p></li><li><p>给x加c 找x离散化之后的数是多少</p></li><li><p>L,R 也会放到离散化的容器中，这样可以方便找到需要求的值</p></li><li><p>unique实现：</p><ol><li>它是第一个数</li><li>它和前一个数不一样，即：a[i] !&#x3D; a[i-1]</li></ol><p><img src="https://s2.loli.net/2022/05/15/FDjnBKP86rUbfC3.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/FDjnBKP86rUbfC3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220217151011007"></p></li></ul><hr></div><div class="story post-story"><h2 id="9-区间合并"><a href="#9-区间合并" class="headerlink" title="9. 区间合并"></a>9. 区间合并</h2><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><img src="https://s2.loli.net/2022/05/15/XRuH1naLwMge8DY.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/XRuH1naLwMge8DY.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220217152352262" style="zoom: 33%;" /><ol><li>按左端点排序</li><li>存在三种情况，分别来看如何对区间进行更新（由于已经排序且是从左到右进行扫描，因此左端点不可能在目前区间左边）<ol><li>在目前的区间内</li><li>左端点在区间内，右端点在区间外</li><li>左端点在区间外</li></ol></li></ol></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> AcWing算法基础课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0. 绪论（白板推导）</title>
      <link href="/2022/05/14/0-%E7%BB%AA%E8%AE%BA%EF%BC%88%E7%99%BD%E6%9D%BF%E6%8E%A8%E5%AF%BC%EF%BC%89/"/>
      <url>/2022/05/14/0-%E7%BB%AA%E8%AE%BA%EF%BC%88%E7%99%BD%E6%9D%BF%E6%8E%A8%E5%AF%BC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本系列源自：<strong>shuhuai008</strong> <a href="https://space.bilibili.com/97068901/channel/series">https://space.bilibili.com/97068901/channel/series</a></p><p>参考自：<a href="https://www.yuque.com/books/share/f4031f65-70c1-4909-ba01-c47c31398466">https://www.yuque.com/books/share/f4031f65-70c1-4909-ba01-c47c31398466</a></p><span id="more"></span><p><img src="https://s2.loli.net/2022/05/15/7U9h451dzKFGBEY.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/15/7U9h451dzKFGBEY.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>]]></content>
      
      
      <categories>
          
          <category> ML &amp; DL </category>
          
          <category> 白板推导系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> 白板推导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake基础学习</title>
      <link href="/2022/05/12/CMake%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/12/CMake%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本文转载自：<a href="https://www.bilibili.com/video/BV1vR4y1u77h?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1vR4y1u77h?spm_id_from=333.337.search-card.all.click</a></p><p>作者：刘贝斯</p><blockquote><p>我对这篇笔记进行了部分修改以增加可读性，强烈想要推荐入门CMake的朋友看一下up的视频和官方文档。</p><p>埋坑：我要写好官方文档的笔记</p></blockquote><span id="more"></span><div class="story post-story"><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>cmake的定义是什么 ？—–高级编译配置工具</p><p>当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了—–CMake！</p><p>所有操作都是通过编译CMakeLists.txt来完成的—简单</p><p>官方网站是 <a href="http://www.cmake.org/">www.cmake.org</a>，可以通过访问官方网站获得更多关于 cmake 的信息</p><p>学习CMake的目的，为将来处理大型的C&#x2F;C++&#x2F;JAVA项目做准备</p></div><div class="story post-story"><h2 id="CMake安装"><a href="#CMake安装" class="headerlink" title="CMake安装"></a>CMake安装</h2><p>1、绝大多数的linux系统已经安装了CMake</p><p>2、Windows或某些没有安装过的linux系统，去<a href="http://www.cmake.org/HTML/Download.html">http://www.cmake.org/HTML/Download.htm</a>l  可以下载安装</p></div><div class="story post-story"><h2 id="CMake一个HelloWord"><a href="#CMake一个HelloWord" class="headerlink" title="CMake一个HelloWord"></a>CMake一个HelloWord</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>1、步骤一，写一个HelloWord</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt;  <span class="string">&quot;hello word&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、步骤二，写CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#CMakeLists.<span class="function">txt</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">PROJECT</span> <span class="params">(HELLO)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">SET</span><span class="params">(SRC_LIST main.cpp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">&quot;This is BINARY dir &quot;</span> $&#123;HELLO_BINARY_DIR&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">&quot;This is SOURCE dir &quot;</span>$&#123;HELLO_SOURCE_DIR&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ADD_EXECUTABLE</span><span class="params">(hello $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure><p>3、步骤三、使用cmake，生成makefile文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[root@localhost cmake]<span class="meta"># cmake .</span></span><br><span class="line"><span class="function">CMake <span class="title">Warning</span> <span class="params">(dev)</span> in CMakeLists.txt:</span></span><br><span class="line"><span class="function">  Syntax Warning in cmake code at</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    /root/cmake/CMakeLists.txt:<span class="number">7</span>:<span class="number">37</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Argument not separated from preceding token by whitespace.</span></span><br><span class="line"><span class="function">This warning is for project developers.  Use -Wno-dev to suppress it.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- The C compiler identification is GNU <span class="number">10.2</span><span class="number">.1</span></span></span><br><span class="line"><span class="function">-- The CXX compiler identification is GNU <span class="number">10.2</span><span class="number">.1</span></span></span><br><span class="line"><span class="function">-- Check for working C compiler: /usr/bin/cc</span></span><br><span class="line"><span class="function">-- Check for working C compiler: /usr/bin/cc -- works</span></span><br><span class="line"><span class="function">-- Detecting C compiler ABI info</span></span><br><span class="line"><span class="function">-- Detecting C compiler ABI info - done</span></span><br><span class="line"><span class="function">-- Check for working CXX compiler: /usr/bin/c++</span></span><br><span class="line"><span class="function">-- Check for working CXX compiler: /usr/bin/c++ -- works</span></span><br><span class="line"><span class="function">-- Detecting CXX compiler ABI info</span></span><br><span class="line"><span class="function">-- Detecting CXX compiler ABI info - done</span></span><br><span class="line"><span class="function">-- This is BINARY dir /root/cmake</span></span><br><span class="line"><span class="function">-- This is SOURCE dir /root/cmake</span></span><br><span class="line"><span class="function">-- Configuring done</span></span><br><span class="line"><span class="function">-- Generating done</span></span><br><span class="line"><span class="function">-- Build files have been written to: /root/cmake</span></span><br></pre></td></tr></table></figure><p>目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.<br>现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile.</p><p>4、使用make命令编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@localhost cmake]<span class="meta"># make</span></span><br><span class="line">Scanning dependencies of target hello</span><br><span class="line">[<span class="number">100</span>%] Building CXX object CMakeFiles/hello.dir/main.cpp.o</span><br><span class="line">Linking CXX executable hello</span><br><span class="line">[<span class="number">100</span>%] Built target hello</span><br></pre></td></tr></table></figure><p>5、最终生成了Hello的可执行程序</p><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><p>在完成前三个步骤之后，可以在vscode下方选择kit，在选择右边的建立，就能够生成build文件（与命令行中的文件一致）</p><p><img src="https://s2.loli.net/2022/05/12/WilIqDfK8pgYcxz.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/12/WilIqDfK8pgYcxz.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><div class="story post-story"><h2 id="CMake一个HelloWord-的语法介绍"><a href="#CMake一个HelloWord-的语法介绍" class="headerlink" title="CMake一个HelloWord-的语法介绍"></a>CMake一个HelloWord-的语法介绍</h2><h3 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h3><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span> (HELLO) <span class="comment"># 工程名字</span></span><br><span class="line"><span class="keyword">PROJECT</span> (HELLO C CXX JAVA) <span class="comment"># 指定工程名字，并且支持C、C++、Java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">PROJECT</span> (HELLO)         <span class="comment"># 指定了工程的名字，并且支持所有语言—建议</span></span><br><span class="line"><span class="keyword">PROJECT</span> (HELLO CXX)     <span class="comment"># 指定了工程的名字，并且支持语言是C++</span></span><br><span class="line"><span class="keyword">PROJECT</span> (HELLO C CXX)   <span class="comment"># 指定了工程的名字，并且支持语言是C和C++</span></span><br></pre></td></tr></table></figure><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</p><p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：</p><p>如果改了工程名，这两个变量名也会改变</p><p>解决：</p><p>又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is BINARY dir &quot;</span> <span class="variable">$&#123;HELLO_BINARY_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is SOURCE dir &quot;</span><span class="variable">$&#123;HELLO_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h3><p>用来显示的指定变量的</p><p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(SRC_LIST main.cpp) </span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(SRC_LIST main.cpp t1.cpp t2.cpp)</span><br></pre></td></tr></table></figure><h3 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h3><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为–的信息。</li></ul><p><img src="https://s2.loli.net/2022/05/12/nPaH28Why3qKiD1.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/12/nPaH28Why3qKiD1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><h3 id="ADD-EXECUTABLE关键字"><a href="#ADD-EXECUTABLE关键字" class="headerlink" title="ADD_EXECUTABLE关键字"></a>ADD_EXECUTABLE关键字</h3><p>生成可执行文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello <span class="variable">$&#123;SRC_LIST&#125;</span>) <span class="comment"># 生成可执行文件hello，源文件读取变量SRC_LIST中的内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.cpp) <span class="comment"># 简写</span></span><br></pre></td></tr></table></figure><p>上述例子（五行代码）可以简化的写成</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(HELLO)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.cpp)</span><br></pre></td></tr></table></figure><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h3 id="语法的基本原则"><a href="#语法的基本原则" class="headerlink" title="语法的基本原则"></a>语法的基本原则</h3><ul><li><p>变量使用 <strong>${}</strong> 方式取值，但是在 <strong>IF</strong> 控制语句中是直接使用变量名</p></li><li><p><strong>指令(参数 1 参数 2…)</strong> 参数使用括弧括起，参数之间使用 <strong>空格</strong> 或 <strong>分号</strong> 分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p><p>就要写成：<strong>ADD_EXECUTABLE(hello main.cpp func.cpp)</strong> 或者 <strong>ADD_EXECUTABLE(hello main.cpp;func.cpp)</strong></p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。<strong>推荐使用大写指令</strong></p></li></ul><h3 id="语法注意事项"><a href="#语法注意事项" class="headerlink" title="语法注意事项"></a>语法注意事项</h3><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不加，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul></div><div class="story post-story"><h2 id="内部构建和外部构建"><a href="#内部构建和外部构建" class="headerlink" title="内部构建和外部构建"></a>内部构建和外部构建</h2><ul><li>上述例子就是内部构建，他生产的临时文件特别多，不方便清理</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式。（这不就是我之前用vscode直接实现的么）</li></ul><h3 id="外部构建方式举例"><a href="#外部构建方式举例" class="headerlink" title="外部构建方式举例"></a>外部构建方式举例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"></span><br><span class="line">cd build</span><br><span class="line"></span><br><span class="line">cmake .. # 注意这里有一个空格</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake ..    当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 &#x2F;root&#x2F;cmake&#x2F;bulid</p><p><img src="https://s2.loli.net/2022/05/12/UXFhiBkn6PlzbdZ.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/12/UXFhiBkn6PlzbdZ.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><div class="story post-story"><h2 id="让Hello-World看起来更像一个工程"><a href="#让Hello-World看起来更像一个工程" class="headerlink" title="让Hello World看起来更像一个工程"></a>让Hello World看起来更像一个工程</h2><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT&#x2F;README 安装到&#x2F;usr&#x2F;share&#x2F;doc&#x2F;cmake&#x2F;</li></ul><h3 id="将目标文件放入构建目录的-bin-子目录"><a href="#将目标文件放入构建目录的-bin-子目录" class="headerlink" title="将目标文件放入构建目录的 bin 子目录"></a>将目标文件放入构建目录的 bin 子目录</h3><blockquote><p>mac没有tree命令，可以使用 brew install tree</p></blockquote><p>每个目录下都要有一个CMakeLists.txt说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>外层CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(HELLO)</span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(src bin) <span class="comment"># src表示和src文件相关联</span></span><br><span class="line"><span class="comment"># bin表示生产的二进制文件、可执行文件等都会放入bin目录中，bin会自动新建</span></span><br></pre></td></tr></table></figure><p>src下的CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ADD_EXECUTABLE</span>(hello main.cpp)</span><br></pre></td></tr></table></figure><h3 id="ADD-SUBDIRECTORY-指令"><a href="#ADD-SUBDIRECTORY-指令" class="headerlink" title="ADD_SUBDIRECTORY 指令"></a>ADD_SUBDIRECTORY 指令</h3><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p><p>(在最外层告诉CMake有src)</p><ul><li><p>这个指令用于向<strong>当前工程</strong>添加<strong>存放源文件的子目录</strong>，并可以<strong>指定中间二进制和目标二进制存放的位置</strong></p></li><li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build&#x2F;src 目录</p></li></ul><h3 id="更改二进制的保存路径"><a href="#更改二进制的保存路径" class="headerlink" title="更改二进制的保存路径"></a>更改二进制的保存路径</h3><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}&#x2F;bin)<br>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}&#x2F;lib)</p><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 命令行使用</span><br><span class="line"></span><br><span class="line">mkdir src</span><br><span class="line"></span><br><span class="line">mv main.cpp src</span><br><span class="line"></span><br><span class="line">cd src</span><br><span class="line"></span><br><span class="line">touch CMakeLists.txt</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">cat CMakeLists.txt # 查看文件内容</span><br><span class="line"></span><br><span class="line">echo &quot;&quot; &gt; CMakeLists.txt # 清空文件</span><br></pre></td></tr></table></figure></div><div class="story post-story"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>一种是从代码编译后直接 make install 安装</li><li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：make install DESTDIR&#x3D;&#x2F;tmp&#x2F;test</li><li>稍微复杂一点可以这样指定目录：.&#x2F;configure –prefix&#x3D;&#x2F;usr</li></ul></li></ul><h3 id="如何安装HelloWord"><a href="#如何安装HelloWord" class="headerlink" title="如何安装HelloWord"></a>如何安装HelloWord</h3><p>使用CMAKE一个新的指令：INSTALL</p><p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录树结构</span></span><br><span class="line">[root@localhost cmake]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── COPYRIGHT</span><br><span class="line">├── doc</span><br><span class="line">│   └── hello.txt</span><br><span class="line">├── README</span><br><span class="line">├── runhello.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">7</span> files</span><br></pre></td></tr></table></figure><h3 id="安装文件COPYRIGHT和README"><a href="#安装文件COPYRIGHT和README" class="headerlink" title="安装文件COPYRIGHT和README"></a>安装文件COPYRIGHT和README</h3><p>INSTALL(FILES COPYRIGHT README DESTINATION share&#x2F;doc&#x2F;cmake&#x2F;)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSTALL</span>(FILES COPYRIGHT README DESTINATION share/doc/cmake/) <span class="comment"># 相对路径</span></span><br></pre></td></tr></table></figure><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}&#x2F;&lt;DESTINATION 定义的路径&gt;</p><p>CMAKE_INSTALL_PREFIX  默认是在 &#x2F;usr&#x2F;local&#x2F;</p><p>cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h3 id="安装脚本runhello-sh"><a href="#安装脚本runhello-sh" class="headerlink" title="安装脚本runhello.sh"></a>安装脚本runhello.sh</h3><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(PROGRAMS runhello.sh DESTINATION bin)</span><br></pre></td></tr></table></figure><p>说明：实际安装到的是 &#x2F;usr&#x2F;bin</p><h3 id="安装-doc-中的-hello-txt"><a href="#安装-doc-中的-hello-txt" class="headerlink" title="安装 doc 中的 hello.txt"></a>安装 doc 中的 hello.txt</h3><ul><li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li><li><p>二、是直接在工程目录通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</span><br></pre></td></tr></table></figure></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc&#x2F;有很大的区别</p><p>目录名不以&#x2F;结尾：这个目录将被安装为目标路径下的</p><p>目录名以&#x2F;结尾：将这个目录中的内容安装到目标路径</p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>cmake ..</p><p>make</p><p>make install</p><p>遇到报错：</p><p><img src="https://s2.loli.net/2022/05/12/ELbDtWQSecryiu8.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/12/ELbDtWQSecryiu8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>解决办法：</p><p><code>sudo make install</code></p></div><div class="story post-story"><h2 id="静态库和动态库的构建"><a href="#静态库和动态库的构建" class="headerlink" title="静态库和动态库的构建"></a>静态库和动态库的构建</h2><p>任务：</p><ol><li><p>建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 </p></li><li><p>安装头文件与共享库。</p></li></ol><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h3 id="构建实例"><a href="#构建实例" class="headerlink" title="构建实例"></a>构建实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake2]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── lib</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── hello.cpp</span><br><span class="line">    └── hello.h</span><br></pre></td></tr></table></figure><p>hello.h中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hello_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>hello.cpp中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中的cmake内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PROJECT</span>(HELLO)</span><br><span class="line"><span class="built_in">ADD_SUBDIRECTORY</span>(lib bin)</span><br></pre></td></tr></table></figure><p>lib中CMakeLists.txt中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br></pre></td></tr></table></figure><h3 id="ADD-LIBRARY"><a href="#ADD-LIBRARY" class="headerlink" title="ADD_LIBRARY"></a>ADD_LIBRARY</h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so(我的mac生产的动态库的后缀是.dylib)</li><li>SHARED，动态库    STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h3 id="同时构建静态和动态库"><a href="#同时构建静态和动态库" class="headerlink" title="同时构建静态和动态库"></a>同时构建静态和动态库</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br></pre></td></tr></table></figure><h3 id="SET-TARGET-PROPERTIES"><a href="#SET-TARGET-PROPERTIES" class="headerlink" title="SET_TARGET_PROPERTIES"></a>SET_TARGET_PROPERTIES</h3><p>这条指令可以用来<strong>设置输出的名称</strong>，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对hello_static的重名为hello</span></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment"># cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span></span><br><span class="line"><span class="comment"># 如果不进行清理就会创建失败</span></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态库的版本号"><a href="#动态库的版本号" class="headerlink" title="动态库的版本号"></a>动态库的版本号</h3><p>一般动态库都有一个版本号的关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libhello.so<span class="number">.1</span><span class="number">.2</span></span><br><span class="line">libhello.so -&gt;libhello.so<span class="number">.1</span></span><br><span class="line">libhello.so<span class="number">.1</span>-&gt;libhello.so<span class="number">.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3 id="安装共享库和头文件"><a href="#安装共享库和头文件" class="headerlink" title="安装共享库和头文件"></a>安装共享库和头文件</h3><p>本例中我们将 hello 的共享库安装到<prefix>&#x2F;lib目录，</p><p>将 hello.h 安装到<prefix>&#x2F;include&#x2F;hello 目录</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件放到该目录下</span></span><br><span class="line"><span class="keyword">INSTALL</span>(FILES hello.h DESTINATION <span class="keyword">include</span>/hello)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制，静态库，动态库安装都用TARGETS</span></span><br><span class="line"><span class="comment"># ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span></span><br><span class="line"><span class="keyword">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -D CMAKE_INSTALL_PREFIX=/usr ..</code></p><h3 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a>使用外部共享库和头文件</h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv cmake3]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hello.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">HelloFunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决：make后头文件找不到的问题"><a href="#解决：make后头文件找不到的问题" class="headerlink" title="解决：make后头文件找不到的问题"></a>解决：make后头文件找不到的问题</h3><p>PS：include &lt;hello&#x2F;hello.h&gt;  这样include是可以，这么做的话，就没啥好讲的了</p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello)</p><p>感谢：</p><p>网友：zcc720的提醒</p><h3 id="解决：找到引用的函数问题"><a href="#解决：找到引用的函数问题" class="headerlink" title="解决：找到引用的函数问题"></a>解决：找到引用的函数问题</h3><p>报错信息：undefined reference to &#96;HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径，LINK_DIRECTORIES(&#x2F;home&#x2F;myproject&#x2F;libs)</p><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv bin]<span class="meta"># ldd main </span></span><br><span class="line">linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007ffedfda4000</span>)</span><br><span class="line">libhello.so =&gt; /lib64/libhello.<span class="built_in">so</span> (<span class="number">0x00007f41c0d8f000</span>)</span><br><span class="line">libstdc++.so<span class="number">.6</span> =&gt; /lib64/libstdc++.so<span class="number">.6</span> (<span class="number">0x00007f41c0874000</span>)</span><br><span class="line">libm.so<span class="number">.6</span> =&gt; /lib64/libm.so<span class="number">.6</span> (<span class="number">0x00007f41c0572000</span>)</span><br><span class="line">libgcc_s.so<span class="number">.1</span> =&gt; /lib64/libgcc_s.so<span class="number">.1</span> (<span class="number">0x00007f41c035c000</span>)</span><br><span class="line">libc.so<span class="number">.6</span> =&gt; /lib64/libc.so<span class="number">.6</span> (<span class="number">0x00007f41bff8e000</span>)</span><br><span class="line">/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f41c0b7c000</span>)</span><br></pre></td></tr></table></figure><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h3 id="特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH"><a href="#特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH" class="headerlink" title="特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH"></a>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h3><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH&#x3D;&#x2F;usr&#x2F;include&#x2F;hello</p><p>补充：生产debug版本的方法：<br>cmake .. -DCMAKE_BUILD_TYPE&#x3D;debug</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D Object</title>
      <link href="/2022/05/11/SRT3D/"/>
      <url>/2022/05/11/SRT3D/</url>
      
        <content type="html"><![CDATA[<h3 id="abstract："><a href="#abstract：" class="headerlink" title="abstract："></a>abstract：</h3><ol><li><p>基于区域的方法很火热，但是计算成本高，需求资源多。</p></li><li><p>我们提出了<strong>SRT3D</strong>可以减小效率上的差距</p><ol><li>我们的模型认为图像信息会沿着对应线稀疏（correspondence lines），对应线会模拟物体的位置概率</li><li>引入smoothed step functions（平滑阶跃函数，西瓜书看到的翻译），用于考量定义的全局和局部的不确定性，对产生的概率公式进行分析</li><li>使用预渲染的稀疏视点模型（sparse viewpoint model）为对象姿势创建联合后验概率。</li><li>使用牛顿…优化</li></ol></li><li><p>运行时间和质量比现有技术好，尤其是噪声和杂乱图像。</p></li></ol><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ol><li>计算机是觉得重要任务之一：跟踪三维空间中的刚体并预测其六自由度。在虚拟现实和机器人都有应用</li><li>给定连续的图像帧，3D目标追踪的目标是：估计对象相对于相机的旋转和平移。</li><li>概述现有技术、相关工作、我们的方法和贡献</li></ol><h4 id="1-1-3D-Object-Tracking"><a href="#1-1-3D-Object-Tracking" class="headerlink" title="1.1 3D Object Tracking"></a>1.1 3D Object Tracking</h4><p>主流方法：</p><table><thead><tr><th>3D目标追踪</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>key-points</td><td>应用广泛、最在不同阶段引入了深度学习</td><td>需要丰富的纹理（rich texture）</td></tr><tr><td>explicit  edges</td><td>提供格外的信息来源</td><td>在复杂场景容易失败（cluttered sccenes）</td></tr><tr><td>direct  optimization</td><td>优化了光度误差（photometric error）</td><td>需要丰富的纹理（rich texture）</td></tr><tr><td></td><td></td><td>motion blur会改变纹理的边缘导致格外问题。</td></tr><tr><td>deep  learning</td><td>使用CNNs考量完整图像信息，效果好</td><td>少数算法能够实时进行、每秒少于30帧、需要高端GPUs、耗时、需要有纹理的3D模型</td></tr><tr><td>depth  information</td><td>使用深度相机（depth cameras）结合深度和RGB信息，总体可以得到更好的效果</td><td>很多应用中，不能使用深度传感器。</td></tr><tr><td></td><td></td><td>由于硬件、表面距离、表面特征和照明条件难以得到算法需要的高质量图像</td></tr><tr><td>image  regions</td><td>在复杂场景中追踪对象、仅使用单目RGB相机和无纹理3D模型<br />过去方法计算成本高，但是我们克服了这一缺点<br />解决了动态模糊的问题，可以快速移动的物体</td><td></td></tr></tbody></table><h4 id="1-2-Related-Work"><a href="#1-2-Related-Work" class="headerlink" title="1.2 Related Work"></a>1.2 Related Work</h4><ol><li>基于区域的方法使用图像统计以区分目标所对应的前景和背景。<ol><li>目标：找到最能展示图像分割的目标姿势以及轮廓。</li><li>潜力：挑战背景下，鲁棒追踪</li><li>最终，PWP3D将分割和追踪结合的方法以及像素级后验成员身份（ the pixel-wise posterior membership）结合，是使用水平集姿势的实时算法。它是几乎所有先进的基于区域的方法的基础。</li></ol></li><li>大量算法对PWP3D进行了改进，如结合格外信息、拓展分割模型、提高效率、使用基于ICP的算法拓展能量函数、使用3D符号距离函数将藕和区域与深度信息结合到概率公式中、使用像素强度值或描述区域（descriptor fields）直接优化目标纹理、基于边缘的使用一个轮廓部分模型的技术。。。一直在介绍不同的技术，但是都只提一句话。</li><li>最后引入自己的技术</li></ol><h4 id="1-3-Contribution"><a href="#1-3-Contribution" class="headerlink" title="1.3 Contribution"></a>1.3 Contribution</h4><ol><li><p>我们致力于开发SRT3D，一种高效、稀疏的基于区域的跟踪方法。为了降低复杂性，我们使用区域信息和采用全局分割模型。我们在先前工作的基础上考虑沿对应线的稀疏图像信息，牛顿优化与Tikhonov正则化被用来估计对象的姿态。</p></li><li><p>我们的贡献：</p><ol><li>对应线的形式定义和描述轮廓位置的概率模型数学推导</li><li>对全局和局部不确定性建模的新的平滑阶跃函数</li><li>参数对后验概率分布的影响</li><li>全局和局部优化策略以及局部一阶导数的新近似</li></ol></li><li><p>之后先将对应线模型的建模，再将算法实现细节。我们的算法在RBOT和OPT上比现有技术效果和质量都更好</p></li></ol><h3 id="Correspondence-Line-Model"><a href="#Correspondence-Line-Model" class="headerlink" title="Correspondence Line Model"></a>Correspondence Line Model</h3><ol><li>对应线的形式化数学定义</li><li>考虑将对应线分割为前景和背景的概率模型</li><li>拓展模型和提供离散比例公式</li><li>新的平滑阶跃函数以及其配置是如何影响轮廓位置的后验概率的</li></ol><h4 id="2-1-Correspondence-Lines"><a href="#2-1-Correspondence-Lines" class="headerlink" title="2.1 Correspondence Lines"></a>2.1 Correspondence Lines</h4><ol><li>我们考虑沿对应线稀疏地处理像素值（类似于ICP，先定义对应关系，再优化）</li><li>建立模型：根据传统的图像的定义建立对应线的定义，并表示出二者关系</li></ol><p>$$<br>\mathbf {l} \left (r \right ) &#x3D; I \left ( \mathbf {c} +r \mathbf {n} \right ) \tag {1}<br>$$</p><h4 id="2-2-Probabilistic-Model"><a href="#2-2-Probabilistic-Model" class="headerlink" title="2.2 Probabilistic Model"></a>2.2 Probabilistic Model</h4><ol><li>提出了一个概率模型，用于将对应线分割为前景区域$\omega_f$和背景区域$\omega_b$。这相当于分割二维图像到区域 到$\Omega_f$和$\Omega_b$</li><li>我们假定前景到背景只有一个过渡（translation），通过线中心（line center） $\mathbf{c}$和相对（$\mathbf{c}$）距离$d$</li></ol><p>从对应线上的单个像素的形成开始推导，联合概率分布如下<br>$$<br>p\left(r, \mathbf{y}, d, m\right ) &#x3D; p\left (r\space| \space d, m\right )p(\mathbf{y} \space |\space m )p(m)p(d) \tag{2}<br>$$</p><blockquote><p>符号解释：<br>$r$：line coordinate（线坐标）</p><p>$\mathbf{y}$：image values（图像值）这里应该是单个像素的值</p><p>$d$：contour distance 相对于线中心$c$的距离</p><p>$m$：$m\in \left { m_f,m_b \right } $ 表示前景或者背景的模型参数</p></blockquote><p>将条件设置为$y$：<br>$$<br>p\left(r, d, m \space | \space \mathbf{y} \right ) &#x3D;<br>p\left (r\space| \space d, m\right )<br>p(m\space |\space \mathbf{y} )<br>p(d) \tag{3}<br>$$</p><blockquote><p>推导过程：</p><p>由于$P(X,Y) &#x3D; P(X)P(X\space |\space Y)$</p><ol><li>$p\left (r\space| \space d, m\right )p(\mathbf{y} \space |\space m )p(m)p(d)<br>&#x3D; p(\mathbf{y} )p(r,d,m\space |\space \mathbf{y} )$</li><li>$p(r,d,m\space |\space \mathbf{y} )<br>&#x3D; \frac{p\left (r\space| \space d, m\right )p(\mathbf{y} \space |\space m )p(m)p(d)<br>}{p(\mathbf{y} )} $</li><li>$\frac{(\mathbf{y} \space |\space m )p(m)<br>}{p(\mathbf{y} )} &#x3D; p(m \space | \space \mathbf{y})$</li><li>$p\left(r, d, m \space | \space \mathbf{y} \right ) &#x3D;<br>p\left (r\space| \space d, m\right )<br>p(m\space |\space \mathbf{y} )<br>p(d)$</li><li>得证</li></ol></blockquote><p>使用贝叶斯和边缘化覆盖$m$来计算像素级后验概率</p><p>$p(\mathbf{y} \space |\space m_f)$和$p(\mathbf{y} \space |\space m_b)$是概率分布，分别描述一个特定的颜色值属于前景区域或背景区域的可能性有多大。可以通过前景区域和后景区域的颜色分布直方图来计算（详见4.2）<br>$$<br>p(m_i \space | \space \mathbf{y}) &#x3D; \frac{p(\mathbf{y} \space |\space m_i)p(m_i)}<br>{ {\textstyle \sum_{j \in { f,b}}^{}}p(\mathbf{y}\space | \space m_j )p(m_j) } ,<br>\space i \in {f, b} \tag{4}<br>$$</p><blockquote><p>同样可以用$P(X,Y) &#x3D; P(X)P(X\space |\space Y)$推出</p></blockquote><p>沿对应线前景和背景的可能性相等$p(m_f) &#x3D; p(m_b)$<br>$$<br>p(m_i \space | \space \mathbf{y}) &#x3D;<br>\frac{p(\mathbf{y} \space |\space m_i)}<br>{p(\mathbf{y}\space | \space m_f )+p(\mathbf{y}\space |\space  m_b) } ,<br>\space i \in {f, b} \tag{5}<br>$$<br>基于（3），边缘化覆盖$m$和$d$在条件$r$下的后验概率<br>$$<br>p(d \space | \space r ,\mathbf{y} ) &#x3D;<br>\frac{1}{p(r)}<br>\sum_{i \in {f, b}}^{}<br>p(r \space |\space d,m_i)p(m_i \space |\space \mathbf{y} )p(d) \tag{6}<br>$$<br>为了计算整个对应线域$\omega$上的后验概率，假设像素独立，基于（6）<br>$$<br>p(d \space | \space \omega ,\mathbf{l} ) \propto<br>\prod_{r \in \omega}^{}<br>\sum_{i \in {f, b}}^{}<br>p(r \space |\space d,m_i)p(m_i \space |\space \mathbf{l}(r) ) \tag{7}<br>$$</p><blockquote><p>$p(r)$和$p(d)$看作是常数所以删除</p><p>这是一个近似的假设，得到的结果十分接近真实值</p><p>条件线坐标概率$p(r \space |\space d,m_i)$在2.4提到，这个概率模型描述了从图像中给定信息的形状内核（shape kernel）的概率</p><p>公式（7）提供了等高线距离数据与对应线的概率。</p></blockquote><h4 id="2-3-Discrete-Scale-Space-Formulation"><a href="#2-3-Discrete-Scale-Space-Formulation" class="headerlink" title="2.3 Discrete Scale-Space Formulation"></a>2.3 Discrete Scale-Space Formulation</h4><table><thead><tr><th></th><th>复杂度</th><th>用途</th></tr></thead><tbody><tr><td>$p(d \space</td><td>\space \omega ,\mathbf{l} )$</td><td>quadratic（平方级）每一个d都要在整个域$\omega$</td></tr><tr><td>$p(m \space</td><td>\space \mathbf{y})$</td><td>linear（线性级）</td></tr></tbody></table><p>从分布转变为像素级后验概率可以提高计算效率</p><p>此外，对对应线进行归一化处理也是有利的，可以确保指向一条对应线的线段中心的线坐标$r$指向所有对应线的线段中心。 （a line coordinate pointing to a segment center for one correspondence line points to a segment  center  for all  correspondence  lines）</p><blockquote><p>我的理解：???</p></blockquote><p> 这种统一的形式可以用于平滑步骤函数值的预计算，以进一步提高效率</p><p>基于先前的研究，我们将多个像素结合至线段中。离散空间尺度公式将沿对应线的连续空间投影至独立于对应线位置和方向的离散空间，如图3</p><p>同一个颜色表示一个segment（线段），蓝色和黄色的点表示segment的中心和对应的离散化后的值</p><p>偏移量∆r的选择要确保标度空间中的离散值对所有对应线都是一样的。在这个例子中，∆r指向像素之间最接近的边缘。</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/08/52d7334d49e20b74.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2022/05/08/52d7334d49e20b74.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>$$<br>r_s &#x3D; (r - \Delta r) \frac{\overline{n} }{s}  \tag{8}<br>$$</p><p>$$<br>d_s &#x3D; (d - \Delta r) \frac{\overline{n} }{s}  \tag{9}<br>$$</p><blockquote><p>$s$：合成为一段线段segment的像素比例（数量）</p><p>$\overline{n} &#x3D; max (|n_x|,|n_y|)$：将对应线投影到最近的水平或垂直图像坐标的主要的绝对法向分量</p><p>$\Delta r \in R$：从对应线中心$c$到定义的像素位置的距离（c所在的像素相邻两个像素中，c更接近的那个边缘到c的距离）</p><p>我的理解：<br>根据之前的内容的上述公式，以及d的定义：d是相对于中心点c的距离。我们可以理解为：假设r（line coordinate）为距离中心点c的距离。</p><p>这里就可以很好的解释$r&#x2F;d_s$减去偏移量$\Delta r$乘以$\frac{\overline{n}}{s}$这一映射关系</p><p>例如：图示的s为2（两个像素构成一个segment），$\overline{n}$为$n_x$（对应线距离水平线投影更近）。从最右边的黄色点来看，减去偏移量后，即$r - \Delta r$为3个单位像素（线坐标下），$n_x$为3，$\frac{\overline{n}}{s}$为1.5，那么对应到$r_s$中，坐标即为1.5如图所示。</p></blockquote><p>根据公式（7），离散尺度空间中的后验概率计算如下：<br>$$<br>p(d_s \space | \space \omega_s ,\mathbf{l}<em>s ) \propto<br>\prod</em>{r_s \in \omega_s}^{}<br>\sum_{i \in {f, b}}^{}<br>p(r_s \space |\space d_s,m_i)p(m_i \space |\space \mathbf{l_s}(r_s) ) \tag{10}<br>$$</p><blockquote><p>$\omega_s$：放缩后到对应线域</p><p>$\mathbf{s} &#x3D; \mathbf{l}_s(r_s)$：一个集值函数映射，它从按比例排列的线坐标映射到线段$s$，这是一个最接近$s$(和上文是一个意思)像素值$y$的集合</p></blockquote><p>类似于公式（5），我们假设像素间具有独立性，分段后验可以被定义为：<br>$$<br>p(m_i \space | \space \mathbf{s}) &#x3D;<br>\frac{\prod_{\mathbf{y} \in \mathbf{s} }p(\mathbf{y} \space |\space m_i)}<br>{\prod_{\mathbf{y} \in \mathbf{s} }p(\mathbf{y}\space | \space m_f )+<br>\prod_{\mathbf{y} \in \mathbf{s} }p(\mathbf{y}\space |\space  m_b) }<br>,\space i \in {f, b}<br>\tag{11}<br>$$<br>这个推导公式，允许使用放缩参数$s$设置线段尺寸和调整准确性和效率之间的取舍，来有效覆盖对应线域$\omega$</p><p>（之后的公式省略了下标s，但是定义和推导对原始空间和离散化空间都有效）</p><h4 id="2-4-Smoothed-Step-Functions"><a href="#2-4-Smoothed-Step-Functions" class="headerlink" title="2.4 Smoothed Step Functions"></a>2.4 Smoothed Step Functions</h4><p>目标：对线坐标的条件概率$p(r|d, m_f)$$p(r|d, m_b)$进行建模，因此提出了不同的平滑阶跃函数$h_f$和$h_b$</p><p>先前的工作：验证了双曲正切曲线会导致后验概率$p(d|\omega , l)$的<strong>高斯分布</strong></p><p>作用：平滑斜率用于模拟与前景和背景过渡的确切位置有关的<strong>局部</strong>不确定性</p><p>错误的假设：给一个模型$m$和轮廓距离$d$，我们就可以根据$h$函数预测线坐标$r$属于轮廓线的哪一边，但是在实际应用中是错误的</p><p>存在的问题：</p><pre><code>1. 等式（5）仍是对真实世界的不完美简化1. 统计模型未考虑图像噪声或快速外观变化，这可能导致颜色直方图中尚未出现的像素颜色1. 由于不完美的分割而被错误分类的像素，然后被分配到错误的颜色直方图1. 一个纯粹依赖像素颜色的统计模型是否足以捕捉现实世界中的所有统计效果，并且能够完美地预测模型$m$</code></pre><p>将上述问题考虑以及前景后景建模的<strong>恒定的全局</strong>不确定性<br>$$<br>h_f(x)&#x3D;\frac{1}{2}-\alpha _h tanh \left (\frac{x}{2s_h}  \right ) \tag{12}<br>$$</p><p>$$<br>h_b(x)&#x3D;\frac{1}{2}+\alpha _h tanh \left (\frac{x}{2s_h}  \right ) \tag{13}<br>$$</p><p>振幅参数$\alpha _h \in \left[0,0.5 \right]$添加到仅考虑坡度参数$s_h \in R^{+}$的原始定义中</p><blockquote><p> 对于$\alpha$的另一种解释：</p><p> 我们假设模型$m$扩展第三类$m_n$，该类$m_n$考虑独立于前景$\omega _f$和后景$\omega _b$的外部影响。对于这个场景，我们可以证明$p(m_f) &#x3D;p(m_b)&#x3D;\alpha $和$p(m_n)&#x3D;1-2\alpha$。</p><p> 根据这种解释，振幅参数因此允许我们设置一个像素的颜色由前景或背景模型生成的概率，与其他一些被视为噪声的影响形成对比。</p><p> 这再次表明，振幅参数α能够模拟恒定的全局不确定性。</p><p> 请注意，在这种情况下，收敛到0或1的原始平滑阶跃函数用于计算$p(r|d,m_f)$和$p(r|d_m)$，而噪声模型采用恒定函数$p(r|d,m_n)&#x3D;\frac{1}{2}$。</p><p> 附录A中给出了该扩展模型的详细推导及其与等式（12）和（13）中函数使用等价性的证明。</p></blockquote><h4 id="2-5-Posteior-Probability-Distrubution"><a href="#2-5-Posteior-Probability-Distrubution" class="headerlink" title="2.5 Posteior Probability Distrubution"></a>2.5 Posteior Probability Distrubution</h4><p>考虑到平滑阶跃函数$h_f和h_b$建立了条件线坐标概率模型$p(r | d,m_f)和p(r | d,m_b)$，则等式（7）中后验概率分布的最终表达式可以写成<br>$$<br>p(d \space | \space \omega ,\mathbf{l} ) \propto<br>\prod_{r \in \omega}^{}<br>h_f(r-d)p_f(r) + h_b(r-d)p_b(r)<br> \tag{14}<br>$$</p><blockquote><p> 缩写：$p_f(r)&#x3D;p(m_f \space |\space  \mathbf{l}(r))和p_b(r)&#x3D;p(m_b \space |\space  \mathbf{l}(r))$</p></blockquote><p>假设轮廓在对应线中心和像素级后验概率$p_f和p_b$的阶跃函数</p><p>阶跃函数的假设很好地反映了现实世界中的实验，实验表明，在大多数情况下，前景和后景之间存在明显的分离</p><p>对公式取对数并关于$d$求一阶导，假设具有无穷小像素的连续函数。基于附录B，封闭解如下：<br>$$<br>\frac{\partial ln(p(d \space | \space \omega, \mathbf{l} ))}{\partial d} &#x3D;<br>-2tanh^{-1}\left (  2 \alpha _h tanh \left ( \frac{d}{2s_h}  \right )\right )<br>\tag{15}<br>$$<br>满足$\alpha _h&#x3D;\frac{1}{2}$和$s_h \to 0$两种情况时，公式（15）可以简化，我们能计算后验概率分布的闭式解。</p><p>$\alpha _h&#x3D;\frac{1}{2}$时，我们获得了我们之前方法的平滑阶跃函数，公式（12）（13），后验概率分布会产生完美的高斯分布<br>$$<br>p(d \space | \space \omega ,\mathbf{l} ) &#x3D;<br>\frac{1}{\sqrt[]{2\pi s_h} }exp\left ( -\frac{d^2}{2s_h}  \right )   \tag{16}<br>$$<br>其中斜率参数$s_h$等于方差。在$s_h \to 0$的情况下，这导致了$h_f$和$h_b$的尖锐阶梯函数，后验概率分布成为一个完美的拉普拉斯分布<br>$$<br>p(d \space | \space \omega ,\mathbf{l} ) &#x3D;<br>\frac{1}{2b} exp\left ( -\frac{|d|}{b\ }  \right )   ,<br>b&#x3D;\frac{1}{2tanh^-1(2 \alpha _h)}<br>\tag{17}<br>$$<br>附录C中有详细推导</p><p>![image-20220424142755366](..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220424142755366.png)</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/08/f0e37a17f34ea0b5.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2022/05/08/f0e37a17f34ea0b5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>拉普拉斯分布（蓝色）有明显的峰值，高斯分布（黄色）有一个平滑的最大值，附近的值有类似的高概率</p><p>从图像中可以知道，$s_h$控制<strong>局部不确定性</strong>（大量的值d可能等于多少），$\alpha _h$控制<strong>全局不确定性</strong>（控制与周围环境相比的峰值大小）</p><h3 id="Region-Based-3D-Tracking"><a href="#Region-Based-3D-Tracking" class="headerlink" title="Region-Based 3D Tracking"></a>Region-Based 3D Tracking</h3><p>内容：</p><ol><li>定义数学概念</li><li>对稀疏视点模型的描述，这个模型避免了在跟踪过程中对三维模型的渲染</li><li>将这种几何学表示与对应线模型结合，制定出与姿势有关的联合后验概率</li><li>该概率通过牛顿优化和Tikhonov正则化实现最大化。 </li><li>我们为牛顿方法定义所需的梯度向量和Hessian矩阵。因此，我们区分了全局和局部优化，以确保快速融合和高精确度。</li></ol><h4 id="3-1-Preliminaries-前言"><a href="#3-1-Preliminaries-前言" class="headerlink" title="3.1 Preliminaries 前言"></a>3.1 Preliminaries 前言</h4><p>定义：3D模型点$\mathbf{X} &#x3D; [X \space Y \space Z]^{T}\in R^{3}$ 其次形式：$\widetilde{\mathbf{X}}  &#x3D; [X \space Y \space Z \space 1]^{T}\in R^{3}$</p><blockquote><p>齐次坐标就是将一个原本是n维的<a href="https://baike.baidu.com/item/%E5%90%91%E9%87%8F/1396519">向量</a>用一个n+1维向量来表示，是指一个用于投影几何里的<a href="https://baike.baidu.com/item/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/4725756">坐标系统</a>，如同用于<a href="https://baike.baidu.com/item/%E6%AC%A7%E6%B0%8F%E5%87%A0%E4%BD%95/2650993">欧氏几何</a>里的笛卡儿坐标一般</p><p>引入齐次坐标可以让放缩变换变得更加统一简单。例如：平移是矩阵加法，而升维之后可以用矩阵乘法实现</p></blockquote><p>对于3D模型点$\mathbf{X}$向图像空间的投影，我们假设图像不失真，并使用针孔相机模型<br>$$<br>x &#x3D; \pi (\mathbf{X} )&#x3D;\begin{bmatrix}<br> \frac{X}{Z}f_x + p_x \ \frac{X}{Z} f_y + p_y<br>\end{bmatrix}<br>\tag{18}<br>$$</p><blockquote><p> 焦距$f_x和f_y$、关键点（principal point）$p_x和p_y$是像素级的</p><p> $x$：图像坐标</p></blockquote><p>反转：从图像坐标$x$和对应深度值$d_Z$沿光轴重建为3D模型点</p><blockquote><p><strong>光轴</strong>是<a href="https://zh.wikipedia.org/wiki/%E5%85%89%E5%AD%B8">光学</a>系统中一条假想的线，定义（在一次近似下）光学系统如何传导光线</p></blockquote><p>$$<br>\mathbf{X}&#x3D;\pi^{-1}(x, d_Z)&#x3D;d_Z\begin{bmatrix}<br> \frac{x-p_x}{f_x} \ \frac{y-p_y}{f_y} \ 1<br>\end{bmatrix}<br>\tag{19}<br>$$</p><p>使用齐次矩阵$_{C}T _M \in SE(3)$描述相机参考系C和模型参考系M之间的相对姿态</p><blockquote><p>SE(3) 是旋转加上位移， 也称欧式变换（Euclidean transformation），刚体变换（Rigid Transformation），一般我们用矩阵 <img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Bbmatrix%7D+%5Cmathbf%7BR%7D++&+t++%5C%5C+%5Cmathbf%7B0%7D++&++1+%5Cend%7Bbmatrix%7D" class="lazyload" data-srcset="https://www.zhihu.com/equation?tex=%5Cbegin%7Bbmatrix%7D+%5Cmathbf%7BR%7D++&+t++%5C%5C+%5Cmathbf%7B0%7D++&++1+%5Cend%7Bbmatrix%7D" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="[公式]"> 来表示，其中 <img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BR%7D" class="lazyload" data-srcset="https://www.zhihu.com/equation?tex=%5Cmathbf%7BR%7D" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="[公式]"> 为旋转， t 为位移，所以有6个自由度，3个旋转，3个位置。</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/08/316ffabcc2615497.jpg" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2022/05/08/316ffabcc2615497.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></blockquote><p>对于一个三维模型点的变换，我们可以写出：<br>$$<br>_{C} \widetilde{X}  &#x3D; _{C}T _{MM} \widetilde{X}&#x3D;\begin{bmatrix}<br> _{C}R_M&amp; -{C}t_M \<br> 0 &amp; 1<br>\end{bmatrix}<br> \space  _{M}\widetilde{X}<br>\tag{20}<br>$$</p><blockquote><p> $_{C} \widetilde{X}$和$ \space  _{M}\widetilde{X}$ 分别是写入相机C和参考系模型参考系M中的3D模型点</p><p> $ _{C}R_M$和$-{C}t_M$是旋转矩阵和平移向量，定义从M到C的转换</p></blockquote><img src="https://s3.bmp.ovh/imgs/2022/05/08/64076aaa9fbca644.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2022/05/08/64076aaa9fbca644.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom:50%;" /><p>对于小的变化，使用角轴表示，这是一个最小的表示。 用指数映射，旋转矩阵写为<br>$$<br>\mathbf{R} &#x3D; exp([\mathbf{r}]_\times)&#x3D;\mathbf{I} + [\mathbf{r}]_\times +<br>\frac{1}{2!}[\mathbf{r}]_\times^{2}+<br>\frac{1}{3!}[\mathbf{r}]_\times^{3}+…<br>\tag{21}<br>$$</p><blockquote><p> $[\mathbf{r}]_\times$是斜对称矩阵,$\mathbf{r} \in R^3$</p></blockquote><p>忽略级数展开的高阶项，等式（21）可以线性化。然后，我们可以在相机参考系C中写入3D模型点的线性变化，如下所示：<br>$$<br>_C\widetilde{X}(\theta) &#x3D;<br>\begin{bmatrix}<br>  _CR_M&amp; Ct_M\<br>  0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br> \mathbf{I} + [\theta_r]_\times &amp; \theta _t \<br> 0 &amp; 1<br>\end{bmatrix}<br>\space _M \widetilde{X}<br>\tag{22}<br>$$</p><blockquote><p>$\theta_r \in R^3$ ：旋转变换</p><p>$\theta _t \in R^3$：平移变换</p><p>$\theta ^T&#x3D;[\theta _r^T,\theta _t^T]$：完变换向量</p></blockquote><p>改变模型参考系M的优点：</p><ol><li>由于对象的移动量通常比相机的移动量大得多，会更加自然</li><li>使&#x3D;&#x3D;拓展为使用多相机算法&#x3D;&#x3D;成为可能</li></ol><h4 id="3-2-Sparse-Viewpoint-Model"><a href="#3-2-Sparse-Viewpoint-Model" class="headerlink" title="3.2 Sparse Viewpoint Model"></a>3.2 Sparse Viewpoint Model</h4><p>为了创建这个模型，三维几何体从物体周围的<strong>若干$n_v$视点</strong>进行渲染</p><p>虚拟摄像机被放置在围绕物体的测地网格的顶点上</p><p>对于每一个渲染，$n_c个点 \mathbf{x_i} \in R^2$从模型轮廓上随机采样（2D上）</p><p>单位向量$\mathbf{n_i} \in R^2$近似垂直于每个点（法向量）</p><p>基于2D实体，关于模型参考系，3D向量被重建：<br>$$<br>_M \mathbf{\widetilde{X} }_i &#x3D;  _{M}T <em>C \mathbf{\widetilde{\pi } }^{-1}(x_i,d</em>{Zi}) \tag{23}<br>$$</p><p>$$<br>_M \mathbf{N}_i  &#x3D; _M\mathbf{R}_C \begin{bmatrix}<br> \mathbf{n} _i  \ 0<br>\end{bmatrix}  \tag{24}<br>$$</p><blockquote><p>$\mathbf{ \widetilde{\pi }}^{-1}$：表示三维模型点以齐次形式返回（他可以将$x和d_Z$（图像值和深度）映射为3D模型点 ）</p><p>$d_{Zi}$：渲染产生的深度值</p><p>$C$：表示虚拟摄像机的，参考系渲染就是从这里开始的</p><p>$_M\mathbf{v}&#x3D;_M \mathbf{R}_C \mathbf{e}_Z$：方向向量，从摄像机指向模型中心$\mathbf{e}_Z&#x3D;\begin{bmatrix} 0 &amp; 0 &amp; 1 \end{bmatrix}^T$</p></blockquote><p>计算的3D模型点、法向量、方向向量会被存储到每一个视图中</p><p>给定特定的姿势（$_M\mathbf{R}_C和_C\mathbf{t}_M$），渲染模型和计算轮廓的过程简化为找到最接近的预计算视图$i_v$：<br>$$<br>i_v &#x3D; \underset{i \in {1,…n_v}}{arg \space max}(_M \mathbf{v}_i^{T}\space _M \mathbf{R}_C \space _C \mathbf{t} _M ) \tag{25}<br>$$<br>然后将相应的3D模型点和法向量投影到图像中</p><p>请注意，在优化关节后验概率时，这种高效率尤其重要，因为每次迭代中姿势都会发生变化。</p><h4 id="3-3-Joint-Posterior-Probability"><a href="#3-3-Joint-Posterior-Probability" class="headerlink" title="3.3 Joint Posterior Probability"></a>3.3 Joint Posterior Probability</h4><p>结合稀疏视点模型与对应线模型，定义关于姿势变换的联合后验概率</p><p>计算之前需要先定义，对应线的位置的方向</p><p>为此，使用以下等式将最接近视图的稀疏视点模型中的3D模型点和法向量投影到图像中：分别为位置和方向<br>$$<br>\mathbf{c}_i &#x3D; \mathbf{\widetilde{\pi } }(_C \mathbf{T} _M \space _M\mathbf{\widetilde{X}}_i)<br>\tag{26}<br>$$</p><p>$$<br>\mathbf{n}_i \propto (_C \mathbf{R} _M \space _M \mathbf{N}<em>i)</em>{2\times1}<br>\tag{27}<br>$$</p><blockquote><p>法向量$\mathbf{n}_i$：被标准化为单位向量</p><p>$()_{2\times1}$：表示向量的前两个元素</p></blockquote><p>所有的对应线被定义后，我们能够变化当前姿势和关于姿势变换向量$\theta$计算轮廓线$d_i$。然后轮廓距离可以通过对应线中心$c_i$到投影后的3D模型点（变为2D）的距离计算：<br>$$<br>d_i(\mathbf{\theta}) &#x3D; \mathbf{n}_i^T(\mathbf{\pi}(_C \mathbf{X}_i(\mathbf{\theta}))-\mathbf{c}_i) \tag{28}<br>$$<br>三维模型点$X_i$与定义对应线的三维模型点$X_i$相同</p><p>3D模型点$_C \mathbf{X}_i$和轮廓距离$d_i$都依赖于<strong>当前姿势</strong>估计$_C \mathbf{T} _M$,这会和用于定义对应线时的姿势不同</p><p>带有变化后的轮廓距离的轮廓线展示如下：</p><p>(虚线是原点，虚线是基于姿势变换向量$\theta$当前估计的轮廓线)</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/08/9cd6ec54392ad90b.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2022/05/08/9cd6ec54392ad90b.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>假设对应线独立，并使用离散化尺度空间（2.3节），联合后验概率被计算如下：<br>$$<br>p(\mathbf{\theta} \space | \space \mathbf{D}) \propto \prod_{i&#x3D;1}^{n_c}p(d_{si}(\mathbf{\theta}) \space | \space \omega <em>{si},\mathbf{l}</em>{si})<br>\tag{29}<br>$$</p><blockquote><p>$\mathbf{D}$描述所有对应线的数据</p></blockquote><p>联合后验概率：描述了当前姿势估计将图像分割成前景区域（对应追踪目标）和后景区域的效果</p><h4 id="3-4-Optimization"><a href="#3-4-Optimization" class="headerlink" title="3.4 Optimization"></a>3.4 Optimization</h4><p>目标：最大化联合后验概率</p><p>方法：估计变化向量$\mathbf{\tilde{\theta}}$并迭代更新姿势</p><p>具体的计算（暂略）</p><p>结论：</p><ol><li>正则化参数对应对应先验概率，控制了我们对先前的姿势（与梯度和Hessian描述的当前估计相比）的信任程度</li><li>对于Hessian表示高度不确定性的方向，正则化有助于保持优化稳定，并避免没有足够数据支持的位置变化</li></ol><h4 id="3-5-Gradient-and-Hessian-Approximation"><a href="#3-5-Gradient-and-Hessian-Approximation" class="headerlink" title="3.5 Gradient and Hessian Approximation"></a>3.5 Gradient and Hessian Approximation</h4><p>梯度向量和Hessian矩阵的近似方式确保了快速收敛和高精度</p><p>为了计算对数后验函数所需的一阶和二阶导数，我们区分了全局优化和局部优化。我们提出了不同的局部优化近似方法，此外，我们要么应用全局优化，要么应用局部优化，并对所有对应线使用相同的导数定义，而不是混合使用</p><p>使用全局优化时，独立对应线的后验概率发布近似正态分布</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3D Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>music test</title>
      <link href="/2022/05/11/%E9%9F%B3%E4%B9%90%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/05/11/%E9%9F%B3%E4%B9%90%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volantis 第一次使用</title>
      <link href="/2022/05/11/Volantis-%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/11/Volantis-%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Hello-world！"><a href="#Hello-world！" class="headerlink" title="Hello world！"></a>Hello world！</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
